<?php
/**
 * DefaultApi
 * PHP version 8.1
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Общение с покупателями
 *
 * <div class=\"description_important\">     Узнать больше об общении с покупателями можно в <a href=\"https://seller.wildberries.ru/instructions/category/f7f6c465-dd12-422d-80a0-a6d9562115d5?goBackOption=prevRoute&categoryId=30817062-14cc-4a82-bc78-3600c2b0685b\">справочном центре</a> </div>  С помощью методов общения с покупателями вы можете работать с:   1. [Вопросами](/openapi/user-communication#tag/Voprosy) и [отзывами](/openapi/user-communication#tag/Otzyvy) покупателей   2. [Закреплёнными отзывами](/openapi/user-communication#tag/Zakreplyonnye-otzyvy)   3. [Чатами с покупателями](/openapi/user-communication#tag/Chat-s-pokupatelyami)   4. [Заявками покупателей на возврат](/openapi/user-communication#tag/Vozvraty-pokupatelyami)
 *
 * The version of the OpenAPI document: communication
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.19.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\FormDataProcessor;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * DefaultApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class DefaultApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'apiFeedbacksV1PinsCountGet' => [
            'application/json',
        ],
        'apiFeedbacksV1PinsDelete' => [
            'application/json',
        ],
        'apiFeedbacksV1PinsGet' => [
            'application/json',
        ],
        'apiFeedbacksV1PinsLimitsGet' => [
            'application/json',
        ],
        'apiFeedbacksV1PinsPost' => [
            'application/json',
        ],
        'apiV1ClaimPatch' => [
            'application/json',
        ],
        'apiV1ClaimsGet' => [
            'application/json',
        ],
        'apiV1FeedbackGet' => [
            'application/json',
        ],
        'apiV1FeedbacksAnswerPatch' => [
            'application/json',
        ],
        'apiV1FeedbacksAnswerPost' => [
            'application/json',
        ],
        'apiV1FeedbacksArchiveGet' => [
            'application/json',
        ],
        'apiV1FeedbacksCountGet' => [
            'application/json',
        ],
        'apiV1FeedbacksCountUnansweredGet' => [
            'application/json',
        ],
        'apiV1FeedbacksGet' => [
            'application/json',
        ],
        'apiV1FeedbacksOrderReturnPost' => [
            'application/json',
        ],
        'apiV1NewFeedbacksQuestionsGet' => [
            'application/json',
        ],
        'apiV1QuestionGet' => [
            'application/json',
        ],
        'apiV1QuestionsCountGet' => [
            'application/json',
        ],
        'apiV1QuestionsCountUnansweredGet' => [
            'application/json',
        ],
        'apiV1QuestionsGet' => [
            'application/json',
        ],
        'apiV1QuestionsPatch' => [
            'application/json',
        ],
        'apiV1SellerChatsGet' => [
            'application/json',
        ],
        'apiV1SellerDownloadIdGet' => [
            'application/json',
        ],
        'apiV1SellerEventsGet' => [
            'application/json',
        ],
        'apiV1SellerMessagePost' => [
            'multipart/form-data',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation apiFeedbacksV1PinsCountGet
     *
     * Количество закреплённых и откреплённых отзывов
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  string|null $state Закреплён ли отзыв:   - &#x60;pinned&#x60; — да   - &#x60;unpinned&#x60; — нет (optional)
     * @param  string|null $pin_on Место закрепления отзыва:   - &#x60;nm&#x60; — карточка товара   - &#x60;imt&#x60; — объединённая карточка (optional)
     * @param  int|null $imt_id ID объединённой карточки товара.&lt;br&gt; Все артикулы WB объединённой карточки товара имеют один и тот же &#x60;imtId&#x60;.&lt;br&gt; У каждой карточки товара есть &#x60;imtId&#x60;, даже если она не объединена с другими карточками (optional)
     * @param  int|null $nm_id Артикул WB (optional)
     * @param  int|null $feedback_id ID отзыва (optional)
     * @param  \DateTime|null $date_from Дата закрепления первого отзыва в списке (optional)
     * @param  \DateTime|null $date_to Дата закрепления последнего отзыва в списке (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiFeedbacksV1PinsCountGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ApiFeedbacksV1PinsCountGet200Response|\OpenAPI\Client\Model\RespondResultErr|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response
     */
    public function apiFeedbacksV1PinsCountGet($state = null, $pin_on = null, $imt_id = null, $nm_id = null, $feedback_id = null, $date_from = null, $date_to = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiFeedbacksV1PinsCountGet'][0])
    {
        list($response) = $this->apiFeedbacksV1PinsCountGetWithHttpInfo($state, $pin_on, $imt_id, $nm_id, $feedback_id, $date_from, $date_to, $hostIndex, $variables, $contentType);
        return $response;
    }

    /**
     * Operation apiFeedbacksV1PinsCountGetWithHttpInfo
     *
     * Количество закреплённых и откреплённых отзывов
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  string|null $state Закреплён ли отзыв:   - &#x60;pinned&#x60; — да   - &#x60;unpinned&#x60; — нет (optional)
     * @param  string|null $pin_on Место закрепления отзыва:   - &#x60;nm&#x60; — карточка товара   - &#x60;imt&#x60; — объединённая карточка (optional)
     * @param  int|null $imt_id ID объединённой карточки товара.&lt;br&gt; Все артикулы WB объединённой карточки товара имеют один и тот же &#x60;imtId&#x60;.&lt;br&gt; У каждой карточки товара есть &#x60;imtId&#x60;, даже если она не объединена с другими карточками (optional)
     * @param  int|null $nm_id Артикул WB (optional)
     * @param  int|null $feedback_id ID отзыва (optional)
     * @param  \DateTime|null $date_from Дата закрепления первого отзыва в списке (optional)
     * @param  \DateTime|null $date_to Дата закрепления последнего отзыва в списке (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiFeedbacksV1PinsCountGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ApiFeedbacksV1PinsCountGet200Response|\OpenAPI\Client\Model\RespondResultErr|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiFeedbacksV1PinsCountGetWithHttpInfo($state = null, $pin_on = null, $imt_id = null, $nm_id = null, $feedback_id = null, $date_from = null, $date_to = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiFeedbacksV1PinsCountGet'][0])
    {
        $request = $this->apiFeedbacksV1PinsCountGetRequest($state, $pin_on, $imt_id, $nm_id, $feedback_id, $date_from, $date_to, $hostIndex, $variables, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiFeedbacksV1PinsCountGet200Response',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\RespondResultErr',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $request,
                        $response,
                    );
                case 429:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ApiFeedbacksV1PinsCountGet200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiFeedbacksV1PinsCountGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RespondResultErr',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation apiFeedbacksV1PinsCountGetAsync
     *
     * Количество закреплённых и откреплённых отзывов
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  string|null $state Закреплён ли отзыв:   - &#x60;pinned&#x60; — да   - &#x60;unpinned&#x60; — нет (optional)
     * @param  string|null $pin_on Место закрепления отзыва:   - &#x60;nm&#x60; — карточка товара   - &#x60;imt&#x60; — объединённая карточка (optional)
     * @param  int|null $imt_id ID объединённой карточки товара.&lt;br&gt; Все артикулы WB объединённой карточки товара имеют один и тот же &#x60;imtId&#x60;.&lt;br&gt; У каждой карточки товара есть &#x60;imtId&#x60;, даже если она не объединена с другими карточками (optional)
     * @param  int|null $nm_id Артикул WB (optional)
     * @param  int|null $feedback_id ID отзыва (optional)
     * @param  \DateTime|null $date_from Дата закрепления первого отзыва в списке (optional)
     * @param  \DateTime|null $date_to Дата закрепления последнего отзыва в списке (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiFeedbacksV1PinsCountGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiFeedbacksV1PinsCountGetAsync($state = null, $pin_on = null, $imt_id = null, $nm_id = null, $feedback_id = null, $date_from = null, $date_to = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiFeedbacksV1PinsCountGet'][0])
    {
        return $this->apiFeedbacksV1PinsCountGetAsyncWithHttpInfo($state, $pin_on, $imt_id, $nm_id, $feedback_id, $date_from, $date_to, $hostIndex, $variables, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiFeedbacksV1PinsCountGetAsyncWithHttpInfo
     *
     * Количество закреплённых и откреплённых отзывов
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  string|null $state Закреплён ли отзыв:   - &#x60;pinned&#x60; — да   - &#x60;unpinned&#x60; — нет (optional)
     * @param  string|null $pin_on Место закрепления отзыва:   - &#x60;nm&#x60; — карточка товара   - &#x60;imt&#x60; — объединённая карточка (optional)
     * @param  int|null $imt_id ID объединённой карточки товара.&lt;br&gt; Все артикулы WB объединённой карточки товара имеют один и тот же &#x60;imtId&#x60;.&lt;br&gt; У каждой карточки товара есть &#x60;imtId&#x60;, даже если она не объединена с другими карточками (optional)
     * @param  int|null $nm_id Артикул WB (optional)
     * @param  int|null $feedback_id ID отзыва (optional)
     * @param  \DateTime|null $date_from Дата закрепления первого отзыва в списке (optional)
     * @param  \DateTime|null $date_to Дата закрепления последнего отзыва в списке (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiFeedbacksV1PinsCountGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiFeedbacksV1PinsCountGetAsyncWithHttpInfo($state = null, $pin_on = null, $imt_id = null, $nm_id = null, $feedback_id = null, $date_from = null, $date_to = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiFeedbacksV1PinsCountGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ApiFeedbacksV1PinsCountGet200Response';
        $request = $this->apiFeedbacksV1PinsCountGetRequest($state, $pin_on, $imt_id, $nm_id, $feedback_id, $date_from, $date_to, $hostIndex, $variables, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiFeedbacksV1PinsCountGet'
     *
    * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
    * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  string|null $state Закреплён ли отзыв:   - &#x60;pinned&#x60; — да   - &#x60;unpinned&#x60; — нет (optional)
     * @param  string|null $pin_on Место закрепления отзыва:   - &#x60;nm&#x60; — карточка товара   - &#x60;imt&#x60; — объединённая карточка (optional)
     * @param  int|null $imt_id ID объединённой карточки товара.&lt;br&gt; Все артикулы WB объединённой карточки товара имеют один и тот же &#x60;imtId&#x60;.&lt;br&gt; У каждой карточки товара есть &#x60;imtId&#x60;, даже если она не объединена с другими карточками (optional)
     * @param  int|null $nm_id Артикул WB (optional)
     * @param  int|null $feedback_id ID отзыва (optional)
     * @param  \DateTime|null $date_from Дата закрепления первого отзыва в списке (optional)
     * @param  \DateTime|null $date_to Дата закрепления последнего отзыва в списке (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiFeedbacksV1PinsCountGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiFeedbacksV1PinsCountGetRequest($state = null, $pin_on = null, $imt_id = null, $nm_id = null, $feedback_id = null, $date_from = null, $date_to = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiFeedbacksV1PinsCountGet'][0])
    {









        $resourcePath = '/api/feedbacks/v1/pins/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $state,
            'state', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pin_on,
            'pinOn', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $imt_id,
            'imtId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $nm_id,
            'nmId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $feedback_id,
            'feedbackId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date_from,
            'dateFrom', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date_to,
            'dateTo', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        # Preserve the original behavior of server indexing.
        if ($hostIndex === null) {
            $hostIndex = $this->hostIndex;
        }

        $hostSettings = $this->getHostSettingsForapiFeedbacksV1PinsCountGet();

        if ($hostIndex < 0 || $hostIndex >= count($hostSettings)) {
            throw new \InvalidArgumentException("Invalid index {$hostIndex} when selecting the host. Must be less than ".count($hostSettings));
        }
        $operationHost = Configuration::getHostString($hostSettings, $hostIndex, $variables);
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Returns an array of host settings for Operation apiFeedbacksV1PinsCountGet
     *
     * @return array an array of host settings
     */
    protected function getHostSettingsForapiFeedbacksV1PinsCountGet(): array
    {
        return [
            [
                "url" => "https://feedbacks-api.wildberries.ru",
                "description" => "No description provided",
            ]
        ];
    }

    /**
     * Operation apiFeedbacksV1PinsDelete
     *
     * Открепить отзывы
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  int[] $request_body Список &#x60;pinId&#x60; — ID операций закрепления отзывов (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiFeedbacksV1PinsDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ApiFeedbacksV1PinsDelete200Response|\OpenAPI\Client\Model\RespondResultErr|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response
     */
    public function apiFeedbacksV1PinsDelete($request_body, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiFeedbacksV1PinsDelete'][0])
    {
        list($response) = $this->apiFeedbacksV1PinsDeleteWithHttpInfo($request_body, $hostIndex, $variables, $contentType);
        return $response;
    }

    /**
     * Operation apiFeedbacksV1PinsDeleteWithHttpInfo
     *
     * Открепить отзывы
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  int[] $request_body Список &#x60;pinId&#x60; — ID операций закрепления отзывов (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiFeedbacksV1PinsDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ApiFeedbacksV1PinsDelete200Response|\OpenAPI\Client\Model\RespondResultErr|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiFeedbacksV1PinsDeleteWithHttpInfo($request_body, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiFeedbacksV1PinsDelete'][0])
    {
        $request = $this->apiFeedbacksV1PinsDeleteRequest($request_body, $hostIndex, $variables, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiFeedbacksV1PinsDelete200Response',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\RespondResultErr',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $request,
                        $response,
                    );
                case 429:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ApiFeedbacksV1PinsDelete200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiFeedbacksV1PinsDelete200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RespondResultErr',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation apiFeedbacksV1PinsDeleteAsync
     *
     * Открепить отзывы
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  int[] $request_body Список &#x60;pinId&#x60; — ID операций закрепления отзывов (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiFeedbacksV1PinsDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiFeedbacksV1PinsDeleteAsync($request_body, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiFeedbacksV1PinsDelete'][0])
    {
        return $this->apiFeedbacksV1PinsDeleteAsyncWithHttpInfo($request_body, $hostIndex, $variables, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiFeedbacksV1PinsDeleteAsyncWithHttpInfo
     *
     * Открепить отзывы
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  int[] $request_body Список &#x60;pinId&#x60; — ID операций закрепления отзывов (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiFeedbacksV1PinsDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiFeedbacksV1PinsDeleteAsyncWithHttpInfo($request_body, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiFeedbacksV1PinsDelete'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ApiFeedbacksV1PinsDelete200Response';
        $request = $this->apiFeedbacksV1PinsDeleteRequest($request_body, $hostIndex, $variables, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiFeedbacksV1PinsDelete'
     *
    * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
    * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  int[] $request_body Список &#x60;pinId&#x60; — ID операций закрепления отзывов (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiFeedbacksV1PinsDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiFeedbacksV1PinsDeleteRequest($request_body, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiFeedbacksV1PinsDelete'][0])
    {

        // verify the required parameter 'request_body' is set
        if ($request_body === null || (is_array($request_body) && count($request_body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request_body when calling apiFeedbacksV1PinsDelete'
            );
        }
        if (count($request_body) > 500) {
            throw new \InvalidArgumentException('invalid value for "$request_body" when calling DefaultApi.apiFeedbacksV1PinsDelete, number of items must be less than or equal to 500.');
        }
        

        $resourcePath = '/api/feedbacks/v1/pins';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($request_body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($request_body));
            } else {
                $httpBody = $request_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        # Preserve the original behavior of server indexing.
        if ($hostIndex === null) {
            $hostIndex = $this->hostIndex;
        }

        $hostSettings = $this->getHostSettingsForapiFeedbacksV1PinsDelete();

        if ($hostIndex < 0 || $hostIndex >= count($hostSettings)) {
            throw new \InvalidArgumentException("Invalid index {$hostIndex} when selecting the host. Must be less than ".count($hostSettings));
        }
        $operationHost = Configuration::getHostString($hostSettings, $hostIndex, $variables);
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Returns an array of host settings for Operation apiFeedbacksV1PinsDelete
     *
     * @return array an array of host settings
     */
    protected function getHostSettingsForapiFeedbacksV1PinsDelete(): array
    {
        return [
            [
                "url" => "https://feedbacks-api.wildberries.ru",
                "description" => "No description provided",
            ]
        ];
    }

    /**
     * Operation apiFeedbacksV1PinsGet
     *
     * Список закреплённых и откреплённых отзывов
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  string|null $state Закреплён ли отзыв:   - &#x60;pinned&#x60; — да   - &#x60;unpinned&#x60; — нет (optional)
     * @param  string|null $pin_on Место закрепления отзыва:   - &#x60;nm&#x60; — карточка товара   - &#x60;imt&#x60; — объединённая карточка (optional)
     * @param  int|null $imt_id ID объединённой карточки товара.&lt;br&gt; Все артикулы WB объединённой карточки товара имеют один и тот же &#x60;imtId&#x60;.&lt;br&gt; У каждой карточки товара есть &#x60;imtId&#x60;, даже если она не объединена с другими карточками (optional)
     * @param  int|null $nm_id Артикул WB (optional)
     * @param  int|null $feedback_id ID отзыва (optional)
     * @param  \DateTime|null $date_from Дата закрепления первого отзыва в списке (optional)
     * @param  \DateTime|null $date_to Дата закрепления последнего отзыва в списке (optional)
     * @param  int|null $next ID последней операции закрепления (пагинатор) (optional)
     * @param  int|null $limit Количество отзывов на одной странице (пагинация) (optional, default to 500)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiFeedbacksV1PinsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ApiFeedbacksV1PinsGet200Response|\OpenAPI\Client\Model\RespondResultErr|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response
     */
    public function apiFeedbacksV1PinsGet($state = null, $pin_on = null, $imt_id = null, $nm_id = null, $feedback_id = null, $date_from = null, $date_to = null, $next = null, $limit = 500, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiFeedbacksV1PinsGet'][0])
    {
        list($response) = $this->apiFeedbacksV1PinsGetWithHttpInfo($state, $pin_on, $imt_id, $nm_id, $feedback_id, $date_from, $date_to, $next, $limit, $hostIndex, $variables, $contentType);
        return $response;
    }

    /**
     * Operation apiFeedbacksV1PinsGetWithHttpInfo
     *
     * Список закреплённых и откреплённых отзывов
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  string|null $state Закреплён ли отзыв:   - &#x60;pinned&#x60; — да   - &#x60;unpinned&#x60; — нет (optional)
     * @param  string|null $pin_on Место закрепления отзыва:   - &#x60;nm&#x60; — карточка товара   - &#x60;imt&#x60; — объединённая карточка (optional)
     * @param  int|null $imt_id ID объединённой карточки товара.&lt;br&gt; Все артикулы WB объединённой карточки товара имеют один и тот же &#x60;imtId&#x60;.&lt;br&gt; У каждой карточки товара есть &#x60;imtId&#x60;, даже если она не объединена с другими карточками (optional)
     * @param  int|null $nm_id Артикул WB (optional)
     * @param  int|null $feedback_id ID отзыва (optional)
     * @param  \DateTime|null $date_from Дата закрепления первого отзыва в списке (optional)
     * @param  \DateTime|null $date_to Дата закрепления последнего отзыва в списке (optional)
     * @param  int|null $next ID последней операции закрепления (пагинатор) (optional)
     * @param  int|null $limit Количество отзывов на одной странице (пагинация) (optional, default to 500)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiFeedbacksV1PinsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ApiFeedbacksV1PinsGet200Response|\OpenAPI\Client\Model\RespondResultErr|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiFeedbacksV1PinsGetWithHttpInfo($state = null, $pin_on = null, $imt_id = null, $nm_id = null, $feedback_id = null, $date_from = null, $date_to = null, $next = null, $limit = 500, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiFeedbacksV1PinsGet'][0])
    {
        $request = $this->apiFeedbacksV1PinsGetRequest($state, $pin_on, $imt_id, $nm_id, $feedback_id, $date_from, $date_to, $next, $limit, $hostIndex, $variables, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiFeedbacksV1PinsGet200Response',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\RespondResultErr',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $request,
                        $response,
                    );
                case 429:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ApiFeedbacksV1PinsGet200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiFeedbacksV1PinsGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RespondResultErr',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation apiFeedbacksV1PinsGetAsync
     *
     * Список закреплённых и откреплённых отзывов
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  string|null $state Закреплён ли отзыв:   - &#x60;pinned&#x60; — да   - &#x60;unpinned&#x60; — нет (optional)
     * @param  string|null $pin_on Место закрепления отзыва:   - &#x60;nm&#x60; — карточка товара   - &#x60;imt&#x60; — объединённая карточка (optional)
     * @param  int|null $imt_id ID объединённой карточки товара.&lt;br&gt; Все артикулы WB объединённой карточки товара имеют один и тот же &#x60;imtId&#x60;.&lt;br&gt; У каждой карточки товара есть &#x60;imtId&#x60;, даже если она не объединена с другими карточками (optional)
     * @param  int|null $nm_id Артикул WB (optional)
     * @param  int|null $feedback_id ID отзыва (optional)
     * @param  \DateTime|null $date_from Дата закрепления первого отзыва в списке (optional)
     * @param  \DateTime|null $date_to Дата закрепления последнего отзыва в списке (optional)
     * @param  int|null $next ID последней операции закрепления (пагинатор) (optional)
     * @param  int|null $limit Количество отзывов на одной странице (пагинация) (optional, default to 500)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiFeedbacksV1PinsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiFeedbacksV1PinsGetAsync($state = null, $pin_on = null, $imt_id = null, $nm_id = null, $feedback_id = null, $date_from = null, $date_to = null, $next = null, $limit = 500, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiFeedbacksV1PinsGet'][0])
    {
        return $this->apiFeedbacksV1PinsGetAsyncWithHttpInfo($state, $pin_on, $imt_id, $nm_id, $feedback_id, $date_from, $date_to, $next, $limit, $hostIndex, $variables, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiFeedbacksV1PinsGetAsyncWithHttpInfo
     *
     * Список закреплённых и откреплённых отзывов
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  string|null $state Закреплён ли отзыв:   - &#x60;pinned&#x60; — да   - &#x60;unpinned&#x60; — нет (optional)
     * @param  string|null $pin_on Место закрепления отзыва:   - &#x60;nm&#x60; — карточка товара   - &#x60;imt&#x60; — объединённая карточка (optional)
     * @param  int|null $imt_id ID объединённой карточки товара.&lt;br&gt; Все артикулы WB объединённой карточки товара имеют один и тот же &#x60;imtId&#x60;.&lt;br&gt; У каждой карточки товара есть &#x60;imtId&#x60;, даже если она не объединена с другими карточками (optional)
     * @param  int|null $nm_id Артикул WB (optional)
     * @param  int|null $feedback_id ID отзыва (optional)
     * @param  \DateTime|null $date_from Дата закрепления первого отзыва в списке (optional)
     * @param  \DateTime|null $date_to Дата закрепления последнего отзыва в списке (optional)
     * @param  int|null $next ID последней операции закрепления (пагинатор) (optional)
     * @param  int|null $limit Количество отзывов на одной странице (пагинация) (optional, default to 500)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiFeedbacksV1PinsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiFeedbacksV1PinsGetAsyncWithHttpInfo($state = null, $pin_on = null, $imt_id = null, $nm_id = null, $feedback_id = null, $date_from = null, $date_to = null, $next = null, $limit = 500, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiFeedbacksV1PinsGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ApiFeedbacksV1PinsGet200Response';
        $request = $this->apiFeedbacksV1PinsGetRequest($state, $pin_on, $imt_id, $nm_id, $feedback_id, $date_from, $date_to, $next, $limit, $hostIndex, $variables, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiFeedbacksV1PinsGet'
     *
    * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
    * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  string|null $state Закреплён ли отзыв:   - &#x60;pinned&#x60; — да   - &#x60;unpinned&#x60; — нет (optional)
     * @param  string|null $pin_on Место закрепления отзыва:   - &#x60;nm&#x60; — карточка товара   - &#x60;imt&#x60; — объединённая карточка (optional)
     * @param  int|null $imt_id ID объединённой карточки товара.&lt;br&gt; Все артикулы WB объединённой карточки товара имеют один и тот же &#x60;imtId&#x60;.&lt;br&gt; У каждой карточки товара есть &#x60;imtId&#x60;, даже если она не объединена с другими карточками (optional)
     * @param  int|null $nm_id Артикул WB (optional)
     * @param  int|null $feedback_id ID отзыва (optional)
     * @param  \DateTime|null $date_from Дата закрепления первого отзыва в списке (optional)
     * @param  \DateTime|null $date_to Дата закрепления последнего отзыва в списке (optional)
     * @param  int|null $next ID последней операции закрепления (пагинатор) (optional)
     * @param  int|null $limit Количество отзывов на одной странице (пагинация) (optional, default to 500)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiFeedbacksV1PinsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiFeedbacksV1PinsGetRequest($state = null, $pin_on = null, $imt_id = null, $nm_id = null, $feedback_id = null, $date_from = null, $date_to = null, $next = null, $limit = 500, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiFeedbacksV1PinsGet'][0])
    {









        if ($limit !== null && $limit > 500) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling DefaultApi.apiFeedbacksV1PinsGet, must be smaller than or equal to 500.');
        }
        

        $resourcePath = '/api/feedbacks/v1/pins';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $state,
            'state', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pin_on,
            'pinOn', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $imt_id,
            'imtId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $nm_id,
            'nmId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $feedback_id,
            'feedbackId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date_from,
            'dateFrom', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date_to,
            'dateTo', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $next,
            'next', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        # Preserve the original behavior of server indexing.
        if ($hostIndex === null) {
            $hostIndex = $this->hostIndex;
        }

        $hostSettings = $this->getHostSettingsForapiFeedbacksV1PinsGet();

        if ($hostIndex < 0 || $hostIndex >= count($hostSettings)) {
            throw new \InvalidArgumentException("Invalid index {$hostIndex} when selecting the host. Must be less than ".count($hostSettings));
        }
        $operationHost = Configuration::getHostString($hostSettings, $hostIndex, $variables);
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Returns an array of host settings for Operation apiFeedbacksV1PinsGet
     *
     * @return array an array of host settings
     */
    protected function getHostSettingsForapiFeedbacksV1PinsGet(): array
    {
        return [
            [
                "url" => "https://feedbacks-api.wildberries.ru",
                "description" => "No description provided",
            ]
        ];
    }

    /**
     * Operation apiFeedbacksV1PinsLimitsGet
     *
     * Лимиты закреплённых отзывов
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiFeedbacksV1PinsLimitsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ApiFeedbacksV1PinsLimitsGet200Response|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response
     */
    public function apiFeedbacksV1PinsLimitsGet(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiFeedbacksV1PinsLimitsGet'][0])
    {
        list($response) = $this->apiFeedbacksV1PinsLimitsGetWithHttpInfo($hostIndex, $variables, $contentType);
        return $response;
    }

    /**
     * Operation apiFeedbacksV1PinsLimitsGetWithHttpInfo
     *
     * Лимиты закреплённых отзывов
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiFeedbacksV1PinsLimitsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ApiFeedbacksV1PinsLimitsGet200Response|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiFeedbacksV1PinsLimitsGetWithHttpInfo(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiFeedbacksV1PinsLimitsGet'][0])
    {
        $request = $this->apiFeedbacksV1PinsLimitsGetRequest($hostIndex, $variables, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiFeedbacksV1PinsLimitsGet200Response',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $request,
                        $response,
                    );
                case 429:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ApiFeedbacksV1PinsLimitsGet200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiFeedbacksV1PinsLimitsGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation apiFeedbacksV1PinsLimitsGetAsync
     *
     * Лимиты закреплённых отзывов
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiFeedbacksV1PinsLimitsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiFeedbacksV1PinsLimitsGetAsync(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiFeedbacksV1PinsLimitsGet'][0])
    {
        return $this->apiFeedbacksV1PinsLimitsGetAsyncWithHttpInfo($hostIndex, $variables, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiFeedbacksV1PinsLimitsGetAsyncWithHttpInfo
     *
     * Лимиты закреплённых отзывов
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiFeedbacksV1PinsLimitsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiFeedbacksV1PinsLimitsGetAsyncWithHttpInfo(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiFeedbacksV1PinsLimitsGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ApiFeedbacksV1PinsLimitsGet200Response';
        $request = $this->apiFeedbacksV1PinsLimitsGetRequest($hostIndex, $variables, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiFeedbacksV1PinsLimitsGet'
     *
    * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
    * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiFeedbacksV1PinsLimitsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiFeedbacksV1PinsLimitsGetRequest(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiFeedbacksV1PinsLimitsGet'][0])
    {


        $resourcePath = '/api/feedbacks/v1/pins/limits';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        # Preserve the original behavior of server indexing.
        if ($hostIndex === null) {
            $hostIndex = $this->hostIndex;
        }

        $hostSettings = $this->getHostSettingsForapiFeedbacksV1PinsLimitsGet();

        if ($hostIndex < 0 || $hostIndex >= count($hostSettings)) {
            throw new \InvalidArgumentException("Invalid index {$hostIndex} when selecting the host. Must be less than ".count($hostSettings));
        }
        $operationHost = Configuration::getHostString($hostSettings, $hostIndex, $variables);
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Returns an array of host settings for Operation apiFeedbacksV1PinsLimitsGet
     *
     * @return array an array of host settings
     */
    protected function getHostSettingsForapiFeedbacksV1PinsLimitsGet(): array
    {
        return [
            [
                "url" => "https://feedbacks-api.wildberries.ru",
                "description" => "No description provided",
            ]
        ];
    }

    /**
     * Operation apiFeedbacksV1PinsPost
     *
     * Закрепить отзывы
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  \OpenAPI\Client\Model\OpenapiPinReviewItem[] $openapi_pin_review_item openapi_pin_review_item (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiFeedbacksV1PinsPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ApiFeedbacksV1PinsPost200Response|\OpenAPI\Client\Model\RespondResultErr|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response|\OpenAPI\Client\Model\RespondResultErr|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response
     */
    public function apiFeedbacksV1PinsPost($openapi_pin_review_item, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiFeedbacksV1PinsPost'][0])
    {
        list($response) = $this->apiFeedbacksV1PinsPostWithHttpInfo($openapi_pin_review_item, $hostIndex, $variables, $contentType);
        return $response;
    }

    /**
     * Operation apiFeedbacksV1PinsPostWithHttpInfo
     *
     * Закрепить отзывы
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  \OpenAPI\Client\Model\OpenapiPinReviewItem[] $openapi_pin_review_item (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiFeedbacksV1PinsPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ApiFeedbacksV1PinsPost200Response|\OpenAPI\Client\Model\RespondResultErr|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response|\OpenAPI\Client\Model\RespondResultErr|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiFeedbacksV1PinsPostWithHttpInfo($openapi_pin_review_item, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiFeedbacksV1PinsPost'][0])
    {
        $request = $this->apiFeedbacksV1PinsPostRequest($openapi_pin_review_item, $hostIndex, $variables, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiFeedbacksV1PinsPost200Response',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\RespondResultErr',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $request,
                        $response,
                    );
                case 403:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\RespondResultErr',
                        $request,
                        $response,
                    );
                case 429:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ApiFeedbacksV1PinsPost200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiFeedbacksV1PinsPost200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RespondResultErr',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RespondResultErr',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation apiFeedbacksV1PinsPostAsync
     *
     * Закрепить отзывы
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  \OpenAPI\Client\Model\OpenapiPinReviewItem[] $openapi_pin_review_item (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiFeedbacksV1PinsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiFeedbacksV1PinsPostAsync($openapi_pin_review_item, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiFeedbacksV1PinsPost'][0])
    {
        return $this->apiFeedbacksV1PinsPostAsyncWithHttpInfo($openapi_pin_review_item, $hostIndex, $variables, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiFeedbacksV1PinsPostAsyncWithHttpInfo
     *
     * Закрепить отзывы
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  \OpenAPI\Client\Model\OpenapiPinReviewItem[] $openapi_pin_review_item (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiFeedbacksV1PinsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiFeedbacksV1PinsPostAsyncWithHttpInfo($openapi_pin_review_item, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiFeedbacksV1PinsPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ApiFeedbacksV1PinsPost200Response';
        $request = $this->apiFeedbacksV1PinsPostRequest($openapi_pin_review_item, $hostIndex, $variables, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiFeedbacksV1PinsPost'
     *
    * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
    * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  \OpenAPI\Client\Model\OpenapiPinReviewItem[] $openapi_pin_review_item (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiFeedbacksV1PinsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiFeedbacksV1PinsPostRequest($openapi_pin_review_item, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiFeedbacksV1PinsPost'][0])
    {

        // verify the required parameter 'openapi_pin_review_item' is set
        if ($openapi_pin_review_item === null || (is_array($openapi_pin_review_item) && count($openapi_pin_review_item) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $openapi_pin_review_item when calling apiFeedbacksV1PinsPost'
            );
        }
        if (count($openapi_pin_review_item) > 500) {
            throw new \InvalidArgumentException('invalid value for "$openapi_pin_review_item" when calling DefaultApi.apiFeedbacksV1PinsPost, number of items must be less than or equal to 500.');
        }
        

        $resourcePath = '/api/feedbacks/v1/pins';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($openapi_pin_review_item)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($openapi_pin_review_item));
            } else {
                $httpBody = $openapi_pin_review_item;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        # Preserve the original behavior of server indexing.
        if ($hostIndex === null) {
            $hostIndex = $this->hostIndex;
        }

        $hostSettings = $this->getHostSettingsForapiFeedbacksV1PinsPost();

        if ($hostIndex < 0 || $hostIndex >= count($hostSettings)) {
            throw new \InvalidArgumentException("Invalid index {$hostIndex} when selecting the host. Must be less than ".count($hostSettings));
        }
        $operationHost = Configuration::getHostString($hostSettings, $hostIndex, $variables);
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Returns an array of host settings for Operation apiFeedbacksV1PinsPost
     *
     * @return array an array of host settings
     */
    protected function getHostSettingsForapiFeedbacksV1PinsPost(): array
    {
        return [
            [
                "url" => "https://feedbacks-api.wildberries.ru",
                "description" => "No description provided",
            ]
        ];
    }

    /**
     * Operation apiV1ClaimPatch
     *
     * Ответ на заявку покупателя
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://returns-api.wildberries.ru
     *
     * @param  \OpenAPI\Client\Model\ApiV1ClaimPatchRequest $api_v1_claim_patch_request Ответ на заявку (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1ClaimPatch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function apiV1ClaimPatch($api_v1_claim_patch_request, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1ClaimPatch'][0])
    {
        $this->apiV1ClaimPatchWithHttpInfo($api_v1_claim_patch_request, $hostIndex, $variables, $contentType);
    }

    /**
     * Operation apiV1ClaimPatchWithHttpInfo
     *
     * Ответ на заявку покупателя
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://returns-api.wildberries.ru
     *
     * @param  \OpenAPI\Client\Model\ApiV1ClaimPatchRequest $api_v1_claim_patch_request Ответ на заявку (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1ClaimPatch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV1ClaimPatchWithHttpInfo($api_v1_claim_patch_request, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1ClaimPatch'][0])
    {
        $request = $this->apiV1ClaimPatchRequest($api_v1_claim_patch_request, $hostIndex, $variables, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1ClaimPatch400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation apiV1ClaimPatchAsync
     *
     * Ответ на заявку покупателя
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://returns-api.wildberries.ru
     *
     * @param  \OpenAPI\Client\Model\ApiV1ClaimPatchRequest $api_v1_claim_patch_request Ответ на заявку (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1ClaimPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV1ClaimPatchAsync($api_v1_claim_patch_request, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1ClaimPatch'][0])
    {
        return $this->apiV1ClaimPatchAsyncWithHttpInfo($api_v1_claim_patch_request, $hostIndex, $variables, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV1ClaimPatchAsyncWithHttpInfo
     *
     * Ответ на заявку покупателя
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://returns-api.wildberries.ru
     *
     * @param  \OpenAPI\Client\Model\ApiV1ClaimPatchRequest $api_v1_claim_patch_request Ответ на заявку (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1ClaimPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV1ClaimPatchAsyncWithHttpInfo($api_v1_claim_patch_request, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1ClaimPatch'][0])
    {
        $returnType = '';
        $request = $this->apiV1ClaimPatchRequest($api_v1_claim_patch_request, $hostIndex, $variables, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV1ClaimPatch'
     *
    * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
    * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://returns-api.wildberries.ru
     *
     * @param  \OpenAPI\Client\Model\ApiV1ClaimPatchRequest $api_v1_claim_patch_request Ответ на заявку (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1ClaimPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiV1ClaimPatchRequest($api_v1_claim_patch_request, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1ClaimPatch'][0])
    {

        // verify the required parameter 'api_v1_claim_patch_request' is set
        if ($api_v1_claim_patch_request === null || (is_array($api_v1_claim_patch_request) && count($api_v1_claim_patch_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_v1_claim_patch_request when calling apiV1ClaimPatch'
            );
        }


        $resourcePath = '/api/v1/claim';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json; charset=utf-8', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($api_v1_claim_patch_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($api_v1_claim_patch_request));
            } else {
                $httpBody = $api_v1_claim_patch_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        # Preserve the original behavior of server indexing.
        if ($hostIndex === null) {
            $hostIndex = $this->hostIndex;
        }

        $hostSettings = $this->getHostSettingsForapiV1ClaimPatch();

        if ($hostIndex < 0 || $hostIndex >= count($hostSettings)) {
            throw new \InvalidArgumentException("Invalid index {$hostIndex} when selecting the host. Must be less than ".count($hostSettings));
        }
        $operationHost = Configuration::getHostString($hostSettings, $hostIndex, $variables);
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Returns an array of host settings for Operation apiV1ClaimPatch
     *
     * @return array an array of host settings
     */
    protected function getHostSettingsForapiV1ClaimPatch(): array
    {
        return [
            [
                "url" => "https://returns-api.wildberries.ru",
                "description" => "No description provided",
            ]
        ];
    }

    /**
     * Operation apiV1ClaimsGet
     *
     * Заявки покупателей на возврат
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://returns-api.wildberries.ru
     *
     * @param  bool $is_archive Состояние заявки:   * &#x60;false&#x60; — на рассмотрении   * &#x60;true&#x60; — в архиве (required)
     * @param  string|null $id ID заявки (optional)
     * @param  int|null $limit Количество заявок в ответе. По умолчанию &#x60;50&#x60; (optional)
     * @param  int|null $offset После какого элемента выдавать данные. По умолчанию &#x60;0&#x60; (optional)
     * @param  int|null $nm_id Артикул WB (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1ClaimsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ApiV1ClaimsGet200Response|\OpenAPI\Client\Model\ApiV1ClaimsGet400Response|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response
     */
    public function apiV1ClaimsGet($is_archive, $id = null, $limit = null, $offset = null, $nm_id = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1ClaimsGet'][0])
    {
        list($response) = $this->apiV1ClaimsGetWithHttpInfo($is_archive, $id, $limit, $offset, $nm_id, $hostIndex, $variables, $contentType);
        return $response;
    }

    /**
     * Operation apiV1ClaimsGetWithHttpInfo
     *
     * Заявки покупателей на возврат
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://returns-api.wildberries.ru
     *
     * @param  bool $is_archive Состояние заявки:   * &#x60;false&#x60; — на рассмотрении   * &#x60;true&#x60; — в архиве (required)
     * @param  string|null $id ID заявки (optional)
     * @param  int|null $limit Количество заявок в ответе. По умолчанию &#x60;50&#x60; (optional)
     * @param  int|null $offset После какого элемента выдавать данные. По умолчанию &#x60;0&#x60; (optional)
     * @param  int|null $nm_id Артикул WB (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1ClaimsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ApiV1ClaimsGet200Response|\OpenAPI\Client\Model\ApiV1ClaimsGet400Response|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV1ClaimsGetWithHttpInfo($is_archive, $id = null, $limit = null, $offset = null, $nm_id = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1ClaimsGet'][0])
    {
        $request = $this->apiV1ClaimsGetRequest($is_archive, $id, $limit, $offset, $nm_id, $hostIndex, $variables, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiV1ClaimsGet200Response',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiV1ClaimsGet400Response',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $request,
                        $response,
                    );
                case 429:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ApiV1ClaimsGet200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1ClaimsGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1ClaimsGet400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation apiV1ClaimsGetAsync
     *
     * Заявки покупателей на возврат
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://returns-api.wildberries.ru
     *
     * @param  bool $is_archive Состояние заявки:   * &#x60;false&#x60; — на рассмотрении   * &#x60;true&#x60; — в архиве (required)
     * @param  string|null $id ID заявки (optional)
     * @param  int|null $limit Количество заявок в ответе. По умолчанию &#x60;50&#x60; (optional)
     * @param  int|null $offset После какого элемента выдавать данные. По умолчанию &#x60;0&#x60; (optional)
     * @param  int|null $nm_id Артикул WB (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1ClaimsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV1ClaimsGetAsync($is_archive, $id = null, $limit = null, $offset = null, $nm_id = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1ClaimsGet'][0])
    {
        return $this->apiV1ClaimsGetAsyncWithHttpInfo($is_archive, $id, $limit, $offset, $nm_id, $hostIndex, $variables, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV1ClaimsGetAsyncWithHttpInfo
     *
     * Заявки покупателей на возврат
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://returns-api.wildberries.ru
     *
     * @param  bool $is_archive Состояние заявки:   * &#x60;false&#x60; — на рассмотрении   * &#x60;true&#x60; — в архиве (required)
     * @param  string|null $id ID заявки (optional)
     * @param  int|null $limit Количество заявок в ответе. По умолчанию &#x60;50&#x60; (optional)
     * @param  int|null $offset После какого элемента выдавать данные. По умолчанию &#x60;0&#x60; (optional)
     * @param  int|null $nm_id Артикул WB (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1ClaimsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV1ClaimsGetAsyncWithHttpInfo($is_archive, $id = null, $limit = null, $offset = null, $nm_id = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1ClaimsGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ApiV1ClaimsGet200Response';
        $request = $this->apiV1ClaimsGetRequest($is_archive, $id, $limit, $offset, $nm_id, $hostIndex, $variables, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV1ClaimsGet'
     *
    * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
    * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://returns-api.wildberries.ru
     *
     * @param  bool $is_archive Состояние заявки:   * &#x60;false&#x60; — на рассмотрении   * &#x60;true&#x60; — в архиве (required)
     * @param  string|null $id ID заявки (optional)
     * @param  int|null $limit Количество заявок в ответе. По умолчанию &#x60;50&#x60; (optional)
     * @param  int|null $offset После какого элемента выдавать данные. По умолчанию &#x60;0&#x60; (optional)
     * @param  int|null $nm_id Артикул WB (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1ClaimsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiV1ClaimsGetRequest($is_archive, $id = null, $limit = null, $offset = null, $nm_id = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1ClaimsGet'][0])
    {

        // verify the required parameter 'is_archive' is set
        if ($is_archive === null || (is_array($is_archive) && count($is_archive) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $is_archive when calling apiV1ClaimsGet'
            );
        }


        if ($limit !== null && $limit > 200) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling DefaultApi.apiV1ClaimsGet, must be smaller than or equal to 200.');
        }
        if ($limit !== null && $limit < 1) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling DefaultApi.apiV1ClaimsGet, must be bigger than or equal to 1.');
        }
        
        if ($offset !== null && $offset < 0) {
            throw new \InvalidArgumentException('invalid value for "$offset" when calling DefaultApi.apiV1ClaimsGet, must be bigger than or equal to 0.');
        }
        


        $resourcePath = '/api/v1/claims';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_archive,
            'is_archive', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $nm_id,
            'nm_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/problem+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        # Preserve the original behavior of server indexing.
        if ($hostIndex === null) {
            $hostIndex = $this->hostIndex;
        }

        $hostSettings = $this->getHostSettingsForapiV1ClaimsGet();

        if ($hostIndex < 0 || $hostIndex >= count($hostSettings)) {
            throw new \InvalidArgumentException("Invalid index {$hostIndex} when selecting the host. Must be less than ".count($hostSettings));
        }
        $operationHost = Configuration::getHostString($hostSettings, $hostIndex, $variables);
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Returns an array of host settings for Operation apiV1ClaimsGet
     *
     * @return array an array of host settings
     */
    protected function getHostSettingsForapiV1ClaimsGet(): array
    {
        return [
            [
                "url" => "https://returns-api.wildberries.ru",
                "description" => "No description provided",
            ]
        ];
    }

    /**
     * Operation apiV1FeedbackGet
     *
     * Получить отзыв по ID
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  string $id ID отзыва (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1FeedbackGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ApiV1FeedbackGet200Response|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response|\OpenAPI\Client\Model\ResponsefeedbackErr|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response
     */
    public function apiV1FeedbackGet($id, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1FeedbackGet'][0])
    {
        list($response) = $this->apiV1FeedbackGetWithHttpInfo($id, $hostIndex, $variables, $contentType);
        return $response;
    }

    /**
     * Operation apiV1FeedbackGetWithHttpInfo
     *
     * Получить отзыв по ID
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  string $id ID отзыва (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1FeedbackGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ApiV1FeedbackGet200Response|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response|\OpenAPI\Client\Model\ResponsefeedbackErr|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV1FeedbackGetWithHttpInfo($id, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1FeedbackGet'][0])
    {
        $request = $this->apiV1FeedbackGetRequest($id, $hostIndex, $variables, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiV1FeedbackGet200Response',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ResponsefeedbackErr',
                        $request,
                        $response,
                    );
                case 429:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ApiV1FeedbackGet200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1FeedbackGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ResponsefeedbackErr',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation apiV1FeedbackGetAsync
     *
     * Получить отзыв по ID
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  string $id ID отзыва (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1FeedbackGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV1FeedbackGetAsync($id, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1FeedbackGet'][0])
    {
        return $this->apiV1FeedbackGetAsyncWithHttpInfo($id, $hostIndex, $variables, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV1FeedbackGetAsyncWithHttpInfo
     *
     * Получить отзыв по ID
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  string $id ID отзыва (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1FeedbackGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV1FeedbackGetAsyncWithHttpInfo($id, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1FeedbackGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ApiV1FeedbackGet200Response';
        $request = $this->apiV1FeedbackGetRequest($id, $hostIndex, $variables, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV1FeedbackGet'
     *
    * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
    * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  string $id ID отзыва (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1FeedbackGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiV1FeedbackGetRequest($id, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1FeedbackGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling apiV1FeedbackGet'
            );
        }


        $resourcePath = '/api/v1/feedback';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        # Preserve the original behavior of server indexing.
        if ($hostIndex === null) {
            $hostIndex = $this->hostIndex;
        }

        $hostSettings = $this->getHostSettingsForapiV1FeedbackGet();

        if ($hostIndex < 0 || $hostIndex >= count($hostSettings)) {
            throw new \InvalidArgumentException("Invalid index {$hostIndex} when selecting the host. Must be less than ".count($hostSettings));
        }
        $operationHost = Configuration::getHostString($hostSettings, $hostIndex, $variables);
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Returns an array of host settings for Operation apiV1FeedbackGet
     *
     * @return array an array of host settings
     */
    protected function getHostSettingsForapiV1FeedbackGet(): array
    {
        return [
            [
                "url" => "https://feedbacks-api.wildberries.ru",
                "description" => "No description provided",
            ]
        ];
    }

    /**
     * Operation apiV1FeedbacksAnswerPatch
     *
     * Отредактировать ответ на отзыв
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  \OpenAPI\Client\Model\ApiV1FeedbacksAnswerPatchRequest|null $api_v1_feedbacks_answer_patch_request api_v1_feedbacks_answer_patch_request (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1FeedbacksAnswerPatch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function apiV1FeedbacksAnswerPatch($api_v1_feedbacks_answer_patch_request = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1FeedbacksAnswerPatch'][0])
    {
        $this->apiV1FeedbacksAnswerPatchWithHttpInfo($api_v1_feedbacks_answer_patch_request, $hostIndex, $variables, $contentType);
    }

    /**
     * Operation apiV1FeedbacksAnswerPatchWithHttpInfo
     *
     * Отредактировать ответ на отзыв
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  \OpenAPI\Client\Model\ApiV1FeedbacksAnswerPatchRequest|null $api_v1_feedbacks_answer_patch_request (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1FeedbacksAnswerPatch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV1FeedbacksAnswerPatchWithHttpInfo($api_v1_feedbacks_answer_patch_request = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1FeedbacksAnswerPatch'][0])
    {
        $request = $this->apiV1FeedbacksAnswerPatchRequest($api_v1_feedbacks_answer_patch_request, $hostIndex, $variables, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation apiV1FeedbacksAnswerPatchAsync
     *
     * Отредактировать ответ на отзыв
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  \OpenAPI\Client\Model\ApiV1FeedbacksAnswerPatchRequest|null $api_v1_feedbacks_answer_patch_request (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1FeedbacksAnswerPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV1FeedbacksAnswerPatchAsync($api_v1_feedbacks_answer_patch_request = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1FeedbacksAnswerPatch'][0])
    {
        return $this->apiV1FeedbacksAnswerPatchAsyncWithHttpInfo($api_v1_feedbacks_answer_patch_request, $hostIndex, $variables, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV1FeedbacksAnswerPatchAsyncWithHttpInfo
     *
     * Отредактировать ответ на отзыв
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  \OpenAPI\Client\Model\ApiV1FeedbacksAnswerPatchRequest|null $api_v1_feedbacks_answer_patch_request (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1FeedbacksAnswerPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV1FeedbacksAnswerPatchAsyncWithHttpInfo($api_v1_feedbacks_answer_patch_request = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1FeedbacksAnswerPatch'][0])
    {
        $returnType = '';
        $request = $this->apiV1FeedbacksAnswerPatchRequest($api_v1_feedbacks_answer_patch_request, $hostIndex, $variables, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV1FeedbacksAnswerPatch'
     *
    * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
    * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  \OpenAPI\Client\Model\ApiV1FeedbacksAnswerPatchRequest|null $api_v1_feedbacks_answer_patch_request (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1FeedbacksAnswerPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiV1FeedbacksAnswerPatchRequest($api_v1_feedbacks_answer_patch_request = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1FeedbacksAnswerPatch'][0])
    {



        $resourcePath = '/api/v1/feedbacks/answer';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($api_v1_feedbacks_answer_patch_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($api_v1_feedbacks_answer_patch_request));
            } else {
                $httpBody = $api_v1_feedbacks_answer_patch_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        # Preserve the original behavior of server indexing.
        if ($hostIndex === null) {
            $hostIndex = $this->hostIndex;
        }

        $hostSettings = $this->getHostSettingsForapiV1FeedbacksAnswerPatch();

        if ($hostIndex < 0 || $hostIndex >= count($hostSettings)) {
            throw new \InvalidArgumentException("Invalid index {$hostIndex} when selecting the host. Must be less than ".count($hostSettings));
        }
        $operationHost = Configuration::getHostString($hostSettings, $hostIndex, $variables);
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Returns an array of host settings for Operation apiV1FeedbacksAnswerPatch
     *
     * @return array an array of host settings
     */
    protected function getHostSettingsForapiV1FeedbacksAnswerPatch(): array
    {
        return [
            [
                "url" => "https://feedbacks-api.wildberries.ru",
                "description" => "No description provided",
            ]
        ];
    }

    /**
     * Operation apiV1FeedbacksAnswerPost
     *
     * Ответить на отзыв
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  \OpenAPI\Client\Model\ApiV1FeedbacksAnswerPostRequest|null $api_v1_feedbacks_answer_post_request api_v1_feedbacks_answer_post_request (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1FeedbacksAnswerPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function apiV1FeedbacksAnswerPost($api_v1_feedbacks_answer_post_request = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1FeedbacksAnswerPost'][0])
    {
        $this->apiV1FeedbacksAnswerPostWithHttpInfo($api_v1_feedbacks_answer_post_request, $hostIndex, $variables, $contentType);
    }

    /**
     * Operation apiV1FeedbacksAnswerPostWithHttpInfo
     *
     * Ответить на отзыв
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  \OpenAPI\Client\Model\ApiV1FeedbacksAnswerPostRequest|null $api_v1_feedbacks_answer_post_request (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1FeedbacksAnswerPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV1FeedbacksAnswerPostWithHttpInfo($api_v1_feedbacks_answer_post_request = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1FeedbacksAnswerPost'][0])
    {
        $request = $this->apiV1FeedbacksAnswerPostRequest($api_v1_feedbacks_answer_post_request, $hostIndex, $variables, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\StandardizedFQError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation apiV1FeedbacksAnswerPostAsync
     *
     * Ответить на отзыв
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  \OpenAPI\Client\Model\ApiV1FeedbacksAnswerPostRequest|null $api_v1_feedbacks_answer_post_request (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1FeedbacksAnswerPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV1FeedbacksAnswerPostAsync($api_v1_feedbacks_answer_post_request = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1FeedbacksAnswerPost'][0])
    {
        return $this->apiV1FeedbacksAnswerPostAsyncWithHttpInfo($api_v1_feedbacks_answer_post_request, $hostIndex, $variables, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV1FeedbacksAnswerPostAsyncWithHttpInfo
     *
     * Ответить на отзыв
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  \OpenAPI\Client\Model\ApiV1FeedbacksAnswerPostRequest|null $api_v1_feedbacks_answer_post_request (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1FeedbacksAnswerPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV1FeedbacksAnswerPostAsyncWithHttpInfo($api_v1_feedbacks_answer_post_request = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1FeedbacksAnswerPost'][0])
    {
        $returnType = '';
        $request = $this->apiV1FeedbacksAnswerPostRequest($api_v1_feedbacks_answer_post_request, $hostIndex, $variables, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV1FeedbacksAnswerPost'
     *
    * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
    * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  \OpenAPI\Client\Model\ApiV1FeedbacksAnswerPostRequest|null $api_v1_feedbacks_answer_post_request (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1FeedbacksAnswerPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiV1FeedbacksAnswerPostRequest($api_v1_feedbacks_answer_post_request = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1FeedbacksAnswerPost'][0])
    {



        $resourcePath = '/api/v1/feedbacks/answer';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($api_v1_feedbacks_answer_post_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($api_v1_feedbacks_answer_post_request));
            } else {
                $httpBody = $api_v1_feedbacks_answer_post_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        # Preserve the original behavior of server indexing.
        if ($hostIndex === null) {
            $hostIndex = $this->hostIndex;
        }

        $hostSettings = $this->getHostSettingsForapiV1FeedbacksAnswerPost();

        if ($hostIndex < 0 || $hostIndex >= count($hostSettings)) {
            throw new \InvalidArgumentException("Invalid index {$hostIndex} when selecting the host. Must be less than ".count($hostSettings));
        }
        $operationHost = Configuration::getHostString($hostSettings, $hostIndex, $variables);
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Returns an array of host settings for Operation apiV1FeedbacksAnswerPost
     *
     * @return array an array of host settings
     */
    protected function getHostSettingsForapiV1FeedbacksAnswerPost(): array
    {
        return [
            [
                "url" => "https://feedbacks-api.wildberries.ru",
                "description" => "No description provided",
            ]
        ];
    }

    /**
     * Operation apiV1FeedbacksArchiveGet
     *
     * Список архивных отзывов
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  int $take Количество отзывов (max. 5 000) (required)
     * @param  int $skip Количество отзывов для пропуска (required)
     * @param  int|null $nm_id Артикул WB (optional)
     * @param  string|null $order Сортировка отзывов по дате (dateAsc/dateDesc) (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1FeedbacksArchiveGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ApiV1FeedbacksArchiveGet200Response|\OpenAPI\Client\Model\ResponsefeedbackErr|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response|\OpenAPI\Client\Model\ResponsefeedbackErr|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response
     */
    public function apiV1FeedbacksArchiveGet($take, $skip, $nm_id = null, $order = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1FeedbacksArchiveGet'][0])
    {
        list($response) = $this->apiV1FeedbacksArchiveGetWithHttpInfo($take, $skip, $nm_id, $order, $hostIndex, $variables, $contentType);
        return $response;
    }

    /**
     * Operation apiV1FeedbacksArchiveGetWithHttpInfo
     *
     * Список архивных отзывов
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  int $take Количество отзывов (max. 5 000) (required)
     * @param  int $skip Количество отзывов для пропуска (required)
     * @param  int|null $nm_id Артикул WB (optional)
     * @param  string|null $order Сортировка отзывов по дате (dateAsc/dateDesc) (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1FeedbacksArchiveGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ApiV1FeedbacksArchiveGet200Response|\OpenAPI\Client\Model\ResponsefeedbackErr|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response|\OpenAPI\Client\Model\ResponsefeedbackErr|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV1FeedbacksArchiveGetWithHttpInfo($take, $skip, $nm_id = null, $order = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1FeedbacksArchiveGet'][0])
    {
        $request = $this->apiV1FeedbacksArchiveGetRequest($take, $skip, $nm_id, $order, $hostIndex, $variables, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiV1FeedbacksArchiveGet200Response',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ResponsefeedbackErr',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $request,
                        $response,
                    );
                case 403:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ResponsefeedbackErr',
                        $request,
                        $response,
                    );
                case 429:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ApiV1FeedbacksArchiveGet200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1FeedbacksArchiveGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ResponsefeedbackErr',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ResponsefeedbackErr',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation apiV1FeedbacksArchiveGetAsync
     *
     * Список архивных отзывов
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  int $take Количество отзывов (max. 5 000) (required)
     * @param  int $skip Количество отзывов для пропуска (required)
     * @param  int|null $nm_id Артикул WB (optional)
     * @param  string|null $order Сортировка отзывов по дате (dateAsc/dateDesc) (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1FeedbacksArchiveGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV1FeedbacksArchiveGetAsync($take, $skip, $nm_id = null, $order = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1FeedbacksArchiveGet'][0])
    {
        return $this->apiV1FeedbacksArchiveGetAsyncWithHttpInfo($take, $skip, $nm_id, $order, $hostIndex, $variables, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV1FeedbacksArchiveGetAsyncWithHttpInfo
     *
     * Список архивных отзывов
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  int $take Количество отзывов (max. 5 000) (required)
     * @param  int $skip Количество отзывов для пропуска (required)
     * @param  int|null $nm_id Артикул WB (optional)
     * @param  string|null $order Сортировка отзывов по дате (dateAsc/dateDesc) (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1FeedbacksArchiveGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV1FeedbacksArchiveGetAsyncWithHttpInfo($take, $skip, $nm_id = null, $order = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1FeedbacksArchiveGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ApiV1FeedbacksArchiveGet200Response';
        $request = $this->apiV1FeedbacksArchiveGetRequest($take, $skip, $nm_id, $order, $hostIndex, $variables, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV1FeedbacksArchiveGet'
     *
    * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
    * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  int $take Количество отзывов (max. 5 000) (required)
     * @param  int $skip Количество отзывов для пропуска (required)
     * @param  int|null $nm_id Артикул WB (optional)
     * @param  string|null $order Сортировка отзывов по дате (dateAsc/dateDesc) (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1FeedbacksArchiveGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiV1FeedbacksArchiveGetRequest($take, $skip, $nm_id = null, $order = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1FeedbacksArchiveGet'][0])
    {

        // verify the required parameter 'take' is set
        if ($take === null || (is_array($take) && count($take) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $take when calling apiV1FeedbacksArchiveGet'
            );
        }

        // verify the required parameter 'skip' is set
        if ($skip === null || (is_array($skip) && count($skip) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $skip when calling apiV1FeedbacksArchiveGet'
            );
        }




        $resourcePath = '/api/v1/feedbacks/archive';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $nm_id,
            'nmId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $take,
            'take', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $skip,
            'skip', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order,
            'order', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        # Preserve the original behavior of server indexing.
        if ($hostIndex === null) {
            $hostIndex = $this->hostIndex;
        }

        $hostSettings = $this->getHostSettingsForapiV1FeedbacksArchiveGet();

        if ($hostIndex < 0 || $hostIndex >= count($hostSettings)) {
            throw new \InvalidArgumentException("Invalid index {$hostIndex} when selecting the host. Must be less than ".count($hostSettings));
        }
        $operationHost = Configuration::getHostString($hostSettings, $hostIndex, $variables);
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Returns an array of host settings for Operation apiV1FeedbacksArchiveGet
     *
     * @return array an array of host settings
     */
    protected function getHostSettingsForapiV1FeedbacksArchiveGet(): array
    {
        return [
            [
                "url" => "https://feedbacks-api.wildberries.ru",
                "description" => "No description provided",
            ]
        ];
    }

    /**
     * Operation apiV1FeedbacksCountGet
     *
     * Количество отзывов
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  int|null $date_from Дата начала периода в формате Unix timestamp (optional)
     * @param  int|null $date_to Дата конца периода в формате Unix timestamp (optional)
     * @param  bool|null $is_answered Обработан ли отзыв:   - &#x60;true&#x60; — да, по умолчанию   - &#x60;false&#x60; — нет (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1FeedbacksCountGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ApiV1FeedbacksCountGet200Response|\OpenAPI\Client\Model\ResponsefeedbackErr|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response|\OpenAPI\Client\Model\ResponsefeedbackErr|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response
     */
    public function apiV1FeedbacksCountGet($date_from = null, $date_to = null, $is_answered = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1FeedbacksCountGet'][0])
    {
        list($response) = $this->apiV1FeedbacksCountGetWithHttpInfo($date_from, $date_to, $is_answered, $hostIndex, $variables, $contentType);
        return $response;
    }

    /**
     * Operation apiV1FeedbacksCountGetWithHttpInfo
     *
     * Количество отзывов
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  int|null $date_from Дата начала периода в формате Unix timestamp (optional)
     * @param  int|null $date_to Дата конца периода в формате Unix timestamp (optional)
     * @param  bool|null $is_answered Обработан ли отзыв:   - &#x60;true&#x60; — да, по умолчанию   - &#x60;false&#x60; — нет (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1FeedbacksCountGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ApiV1FeedbacksCountGet200Response|\OpenAPI\Client\Model\ResponsefeedbackErr|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response|\OpenAPI\Client\Model\ResponsefeedbackErr|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV1FeedbacksCountGetWithHttpInfo($date_from = null, $date_to = null, $is_answered = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1FeedbacksCountGet'][0])
    {
        $request = $this->apiV1FeedbacksCountGetRequest($date_from, $date_to, $is_answered, $hostIndex, $variables, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiV1FeedbacksCountGet200Response',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ResponsefeedbackErr',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $request,
                        $response,
                    );
                case 403:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ResponsefeedbackErr',
                        $request,
                        $response,
                    );
                case 429:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ApiV1FeedbacksCountGet200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1FeedbacksCountGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ResponsefeedbackErr',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ResponsefeedbackErr',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation apiV1FeedbacksCountGetAsync
     *
     * Количество отзывов
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  int|null $date_from Дата начала периода в формате Unix timestamp (optional)
     * @param  int|null $date_to Дата конца периода в формате Unix timestamp (optional)
     * @param  bool|null $is_answered Обработан ли отзыв:   - &#x60;true&#x60; — да, по умолчанию   - &#x60;false&#x60; — нет (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1FeedbacksCountGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV1FeedbacksCountGetAsync($date_from = null, $date_to = null, $is_answered = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1FeedbacksCountGet'][0])
    {
        return $this->apiV1FeedbacksCountGetAsyncWithHttpInfo($date_from, $date_to, $is_answered, $hostIndex, $variables, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV1FeedbacksCountGetAsyncWithHttpInfo
     *
     * Количество отзывов
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  int|null $date_from Дата начала периода в формате Unix timestamp (optional)
     * @param  int|null $date_to Дата конца периода в формате Unix timestamp (optional)
     * @param  bool|null $is_answered Обработан ли отзыв:   - &#x60;true&#x60; — да, по умолчанию   - &#x60;false&#x60; — нет (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1FeedbacksCountGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV1FeedbacksCountGetAsyncWithHttpInfo($date_from = null, $date_to = null, $is_answered = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1FeedbacksCountGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ApiV1FeedbacksCountGet200Response';
        $request = $this->apiV1FeedbacksCountGetRequest($date_from, $date_to, $is_answered, $hostIndex, $variables, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV1FeedbacksCountGet'
     *
    * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
    * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  int|null $date_from Дата начала периода в формате Unix timestamp (optional)
     * @param  int|null $date_to Дата конца периода в формате Unix timestamp (optional)
     * @param  bool|null $is_answered Обработан ли отзыв:   - &#x60;true&#x60; — да, по умолчанию   - &#x60;false&#x60; — нет (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1FeedbacksCountGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiV1FeedbacksCountGetRequest($date_from = null, $date_to = null, $is_answered = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1FeedbacksCountGet'][0])
    {





        $resourcePath = '/api/v1/feedbacks/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date_from,
            'dateFrom', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date_to,
            'dateTo', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_answered,
            'isAnswered', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        # Preserve the original behavior of server indexing.
        if ($hostIndex === null) {
            $hostIndex = $this->hostIndex;
        }

        $hostSettings = $this->getHostSettingsForapiV1FeedbacksCountGet();

        if ($hostIndex < 0 || $hostIndex >= count($hostSettings)) {
            throw new \InvalidArgumentException("Invalid index {$hostIndex} when selecting the host. Must be less than ".count($hostSettings));
        }
        $operationHost = Configuration::getHostString($hostSettings, $hostIndex, $variables);
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Returns an array of host settings for Operation apiV1FeedbacksCountGet
     *
     * @return array an array of host settings
     */
    protected function getHostSettingsForapiV1FeedbacksCountGet(): array
    {
        return [
            [
                "url" => "https://feedbacks-api.wildberries.ru",
                "description" => "No description provided",
            ]
        ];
    }

    /**
     * Operation apiV1FeedbacksCountUnansweredGet
     *
     * Необработанные отзывы
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1FeedbacksCountUnansweredGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ApiV1FeedbacksCountUnansweredGet200Response|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response|\OpenAPI\Client\Model\ResponsefeedbackErr|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response
     */
    public function apiV1FeedbacksCountUnansweredGet(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1FeedbacksCountUnansweredGet'][0])
    {
        list($response) = $this->apiV1FeedbacksCountUnansweredGetWithHttpInfo($hostIndex, $variables, $contentType);
        return $response;
    }

    /**
     * Operation apiV1FeedbacksCountUnansweredGetWithHttpInfo
     *
     * Необработанные отзывы
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1FeedbacksCountUnansweredGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ApiV1FeedbacksCountUnansweredGet200Response|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response|\OpenAPI\Client\Model\ResponsefeedbackErr|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV1FeedbacksCountUnansweredGetWithHttpInfo(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1FeedbacksCountUnansweredGet'][0])
    {
        $request = $this->apiV1FeedbacksCountUnansweredGetRequest($hostIndex, $variables, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiV1FeedbacksCountUnansweredGet200Response',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $request,
                        $response,
                    );
                case 403:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ResponsefeedbackErr',
                        $request,
                        $response,
                    );
                case 429:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ApiV1FeedbacksCountUnansweredGet200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1FeedbacksCountUnansweredGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ResponsefeedbackErr',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation apiV1FeedbacksCountUnansweredGetAsync
     *
     * Необработанные отзывы
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1FeedbacksCountUnansweredGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV1FeedbacksCountUnansweredGetAsync(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1FeedbacksCountUnansweredGet'][0])
    {
        return $this->apiV1FeedbacksCountUnansweredGetAsyncWithHttpInfo($hostIndex, $variables, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV1FeedbacksCountUnansweredGetAsyncWithHttpInfo
     *
     * Необработанные отзывы
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1FeedbacksCountUnansweredGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV1FeedbacksCountUnansweredGetAsyncWithHttpInfo(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1FeedbacksCountUnansweredGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ApiV1FeedbacksCountUnansweredGet200Response';
        $request = $this->apiV1FeedbacksCountUnansweredGetRequest($hostIndex, $variables, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV1FeedbacksCountUnansweredGet'
     *
    * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
    * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1FeedbacksCountUnansweredGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiV1FeedbacksCountUnansweredGetRequest(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1FeedbacksCountUnansweredGet'][0])
    {


        $resourcePath = '/api/v1/feedbacks/count-unanswered';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        # Preserve the original behavior of server indexing.
        if ($hostIndex === null) {
            $hostIndex = $this->hostIndex;
        }

        $hostSettings = $this->getHostSettingsForapiV1FeedbacksCountUnansweredGet();

        if ($hostIndex < 0 || $hostIndex >= count($hostSettings)) {
            throw new \InvalidArgumentException("Invalid index {$hostIndex} when selecting the host. Must be less than ".count($hostSettings));
        }
        $operationHost = Configuration::getHostString($hostSettings, $hostIndex, $variables);
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Returns an array of host settings for Operation apiV1FeedbacksCountUnansweredGet
     *
     * @return array an array of host settings
     */
    protected function getHostSettingsForapiV1FeedbacksCountUnansweredGet(): array
    {
        return [
            [
                "url" => "https://feedbacks-api.wildberries.ru",
                "description" => "No description provided",
            ]
        ];
    }

    /**
     * Operation apiV1FeedbacksGet
     *
     * Список отзывов
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  bool $is_answered Обработан ли отзыв:   - &#x60;true&#x60; — да, по умолчанию   - &#x60;false&#x60; — нет (required)
     * @param  int $take Количество отзывов (max. 5 000) (required)
     * @param  int $skip Количество отзывов для пропуска (max. 199990) (required)
     * @param  int|null $nm_id Артикул WB (optional)
     * @param  string|null $order Сортировка отзывов по дате (dateAsc/dateDesc) (optional)
     * @param  int|null $date_from Дата начала периода в формате Unix timestamp (optional)
     * @param  int|null $date_to Дата конца периода в формате Unix timestamp (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1FeedbacksGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ApiV1FeedbacksGet200Response|\OpenAPI\Client\Model\ResponsefeedbackErr|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response|\OpenAPI\Client\Model\ResponsefeedbackErr|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response
     */
    public function apiV1FeedbacksGet($is_answered, $take, $skip, $nm_id = null, $order = null, $date_from = null, $date_to = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1FeedbacksGet'][0])
    {
        list($response) = $this->apiV1FeedbacksGetWithHttpInfo($is_answered, $take, $skip, $nm_id, $order, $date_from, $date_to, $hostIndex, $variables, $contentType);
        return $response;
    }

    /**
     * Operation apiV1FeedbacksGetWithHttpInfo
     *
     * Список отзывов
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  bool $is_answered Обработан ли отзыв:   - &#x60;true&#x60; — да, по умолчанию   - &#x60;false&#x60; — нет (required)
     * @param  int $take Количество отзывов (max. 5 000) (required)
     * @param  int $skip Количество отзывов для пропуска (max. 199990) (required)
     * @param  int|null $nm_id Артикул WB (optional)
     * @param  string|null $order Сортировка отзывов по дате (dateAsc/dateDesc) (optional)
     * @param  int|null $date_from Дата начала периода в формате Unix timestamp (optional)
     * @param  int|null $date_to Дата конца периода в формате Unix timestamp (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1FeedbacksGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ApiV1FeedbacksGet200Response|\OpenAPI\Client\Model\ResponsefeedbackErr|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response|\OpenAPI\Client\Model\ResponsefeedbackErr|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV1FeedbacksGetWithHttpInfo($is_answered, $take, $skip, $nm_id = null, $order = null, $date_from = null, $date_to = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1FeedbacksGet'][0])
    {
        $request = $this->apiV1FeedbacksGetRequest($is_answered, $take, $skip, $nm_id, $order, $date_from, $date_to, $hostIndex, $variables, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiV1FeedbacksGet200Response',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ResponsefeedbackErr',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $request,
                        $response,
                    );
                case 403:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ResponsefeedbackErr',
                        $request,
                        $response,
                    );
                case 429:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ApiV1FeedbacksGet200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1FeedbacksGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ResponsefeedbackErr',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ResponsefeedbackErr',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation apiV1FeedbacksGetAsync
     *
     * Список отзывов
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  bool $is_answered Обработан ли отзыв:   - &#x60;true&#x60; — да, по умолчанию   - &#x60;false&#x60; — нет (required)
     * @param  int $take Количество отзывов (max. 5 000) (required)
     * @param  int $skip Количество отзывов для пропуска (max. 199990) (required)
     * @param  int|null $nm_id Артикул WB (optional)
     * @param  string|null $order Сортировка отзывов по дате (dateAsc/dateDesc) (optional)
     * @param  int|null $date_from Дата начала периода в формате Unix timestamp (optional)
     * @param  int|null $date_to Дата конца периода в формате Unix timestamp (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1FeedbacksGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV1FeedbacksGetAsync($is_answered, $take, $skip, $nm_id = null, $order = null, $date_from = null, $date_to = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1FeedbacksGet'][0])
    {
        return $this->apiV1FeedbacksGetAsyncWithHttpInfo($is_answered, $take, $skip, $nm_id, $order, $date_from, $date_to, $hostIndex, $variables, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV1FeedbacksGetAsyncWithHttpInfo
     *
     * Список отзывов
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  bool $is_answered Обработан ли отзыв:   - &#x60;true&#x60; — да, по умолчанию   - &#x60;false&#x60; — нет (required)
     * @param  int $take Количество отзывов (max. 5 000) (required)
     * @param  int $skip Количество отзывов для пропуска (max. 199990) (required)
     * @param  int|null $nm_id Артикул WB (optional)
     * @param  string|null $order Сортировка отзывов по дате (dateAsc/dateDesc) (optional)
     * @param  int|null $date_from Дата начала периода в формате Unix timestamp (optional)
     * @param  int|null $date_to Дата конца периода в формате Unix timestamp (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1FeedbacksGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV1FeedbacksGetAsyncWithHttpInfo($is_answered, $take, $skip, $nm_id = null, $order = null, $date_from = null, $date_to = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1FeedbacksGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ApiV1FeedbacksGet200Response';
        $request = $this->apiV1FeedbacksGetRequest($is_answered, $take, $skip, $nm_id, $order, $date_from, $date_to, $hostIndex, $variables, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV1FeedbacksGet'
     *
    * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
    * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  bool $is_answered Обработан ли отзыв:   - &#x60;true&#x60; — да, по умолчанию   - &#x60;false&#x60; — нет (required)
     * @param  int $take Количество отзывов (max. 5 000) (required)
     * @param  int $skip Количество отзывов для пропуска (max. 199990) (required)
     * @param  int|null $nm_id Артикул WB (optional)
     * @param  string|null $order Сортировка отзывов по дате (dateAsc/dateDesc) (optional)
     * @param  int|null $date_from Дата начала периода в формате Unix timestamp (optional)
     * @param  int|null $date_to Дата конца периода в формате Unix timestamp (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1FeedbacksGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiV1FeedbacksGetRequest($is_answered, $take, $skip, $nm_id = null, $order = null, $date_from = null, $date_to = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1FeedbacksGet'][0])
    {

        // verify the required parameter 'is_answered' is set
        if ($is_answered === null || (is_array($is_answered) && count($is_answered) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $is_answered when calling apiV1FeedbacksGet'
            );
        }

        // verify the required parameter 'take' is set
        if ($take === null || (is_array($take) && count($take) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $take when calling apiV1FeedbacksGet'
            );
        }

        // verify the required parameter 'skip' is set
        if ($skip === null || (is_array($skip) && count($skip) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $skip when calling apiV1FeedbacksGet'
            );
        }






        $resourcePath = '/api/v1/feedbacks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_answered,
            'isAnswered', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $nm_id,
            'nmId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $take,
            'take', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $skip,
            'skip', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order,
            'order', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date_from,
            'dateFrom', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date_to,
            'dateTo', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        # Preserve the original behavior of server indexing.
        if ($hostIndex === null) {
            $hostIndex = $this->hostIndex;
        }

        $hostSettings = $this->getHostSettingsForapiV1FeedbacksGet();

        if ($hostIndex < 0 || $hostIndex >= count($hostSettings)) {
            throw new \InvalidArgumentException("Invalid index {$hostIndex} when selecting the host. Must be less than ".count($hostSettings));
        }
        $operationHost = Configuration::getHostString($hostSettings, $hostIndex, $variables);
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Returns an array of host settings for Operation apiV1FeedbacksGet
     *
     * @return array an array of host settings
     */
    protected function getHostSettingsForapiV1FeedbacksGet(): array
    {
        return [
            [
                "url" => "https://feedbacks-api.wildberries.ru",
                "description" => "No description provided",
            ]
        ];
    }

    /**
     * Operation apiV1FeedbacksOrderReturnPost
     *
     * Возврат товара по ID отзыва
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  \OpenAPI\Client\Model\ApiV1FeedbacksOrderReturnPostRequest $api_v1_feedbacks_order_return_post_request api_v1_feedbacks_order_return_post_request (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1FeedbacksOrderReturnPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ApiV1QuestionsPatch200Response|\OpenAPI\Client\Model\ResponsefeedbackErr|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response|\OpenAPI\Client\Model\ResponsefeedbackErr|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response
     */
    public function apiV1FeedbacksOrderReturnPost($api_v1_feedbacks_order_return_post_request, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1FeedbacksOrderReturnPost'][0])
    {
        list($response) = $this->apiV1FeedbacksOrderReturnPostWithHttpInfo($api_v1_feedbacks_order_return_post_request, $hostIndex, $variables, $contentType);
        return $response;
    }

    /**
     * Operation apiV1FeedbacksOrderReturnPostWithHttpInfo
     *
     * Возврат товара по ID отзыва
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  \OpenAPI\Client\Model\ApiV1FeedbacksOrderReturnPostRequest $api_v1_feedbacks_order_return_post_request (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1FeedbacksOrderReturnPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ApiV1QuestionsPatch200Response|\OpenAPI\Client\Model\ResponsefeedbackErr|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response|\OpenAPI\Client\Model\ResponsefeedbackErr|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV1FeedbacksOrderReturnPostWithHttpInfo($api_v1_feedbacks_order_return_post_request, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1FeedbacksOrderReturnPost'][0])
    {
        $request = $this->apiV1FeedbacksOrderReturnPostRequest($api_v1_feedbacks_order_return_post_request, $hostIndex, $variables, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiV1QuestionsPatch200Response',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ResponsefeedbackErr',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ResponsefeedbackErr',
                        $request,
                        $response,
                    );
                case 429:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ApiV1QuestionsPatch200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1QuestionsPatch200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ResponsefeedbackErr',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ResponsefeedbackErr',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation apiV1FeedbacksOrderReturnPostAsync
     *
     * Возврат товара по ID отзыва
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  \OpenAPI\Client\Model\ApiV1FeedbacksOrderReturnPostRequest $api_v1_feedbacks_order_return_post_request (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1FeedbacksOrderReturnPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV1FeedbacksOrderReturnPostAsync($api_v1_feedbacks_order_return_post_request, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1FeedbacksOrderReturnPost'][0])
    {
        return $this->apiV1FeedbacksOrderReturnPostAsyncWithHttpInfo($api_v1_feedbacks_order_return_post_request, $hostIndex, $variables, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV1FeedbacksOrderReturnPostAsyncWithHttpInfo
     *
     * Возврат товара по ID отзыва
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  \OpenAPI\Client\Model\ApiV1FeedbacksOrderReturnPostRequest $api_v1_feedbacks_order_return_post_request (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1FeedbacksOrderReturnPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV1FeedbacksOrderReturnPostAsyncWithHttpInfo($api_v1_feedbacks_order_return_post_request, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1FeedbacksOrderReturnPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ApiV1QuestionsPatch200Response';
        $request = $this->apiV1FeedbacksOrderReturnPostRequest($api_v1_feedbacks_order_return_post_request, $hostIndex, $variables, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV1FeedbacksOrderReturnPost'
     *
    * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
    * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  \OpenAPI\Client\Model\ApiV1FeedbacksOrderReturnPostRequest $api_v1_feedbacks_order_return_post_request (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1FeedbacksOrderReturnPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiV1FeedbacksOrderReturnPostRequest($api_v1_feedbacks_order_return_post_request, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1FeedbacksOrderReturnPost'][0])
    {

        // verify the required parameter 'api_v1_feedbacks_order_return_post_request' is set
        if ($api_v1_feedbacks_order_return_post_request === null || (is_array($api_v1_feedbacks_order_return_post_request) && count($api_v1_feedbacks_order_return_post_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_v1_feedbacks_order_return_post_request when calling apiV1FeedbacksOrderReturnPost'
            );
        }


        $resourcePath = '/api/v1/feedbacks/order/return';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($api_v1_feedbacks_order_return_post_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($api_v1_feedbacks_order_return_post_request));
            } else {
                $httpBody = $api_v1_feedbacks_order_return_post_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        # Preserve the original behavior of server indexing.
        if ($hostIndex === null) {
            $hostIndex = $this->hostIndex;
        }

        $hostSettings = $this->getHostSettingsForapiV1FeedbacksOrderReturnPost();

        if ($hostIndex < 0 || $hostIndex >= count($hostSettings)) {
            throw new \InvalidArgumentException("Invalid index {$hostIndex} when selecting the host. Must be less than ".count($hostSettings));
        }
        $operationHost = Configuration::getHostString($hostSettings, $hostIndex, $variables);
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Returns an array of host settings for Operation apiV1FeedbacksOrderReturnPost
     *
     * @return array an array of host settings
     */
    protected function getHostSettingsForapiV1FeedbacksOrderReturnPost(): array
    {
        return [
            [
                "url" => "https://feedbacks-api.wildberries.ru",
                "description" => "No description provided",
            ]
        ];
    }

    /**
     * Operation apiV1NewFeedbacksQuestionsGet
     *
     * Непросмотренные отзывы и вопросы
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1NewFeedbacksQuestionsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet200Response|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response|\OpenAPI\Client\Model\ResponsefeedbackErr|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response
     */
    public function apiV1NewFeedbacksQuestionsGet(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1NewFeedbacksQuestionsGet'][0])
    {
        list($response) = $this->apiV1NewFeedbacksQuestionsGetWithHttpInfo($hostIndex, $variables, $contentType);
        return $response;
    }

    /**
     * Operation apiV1NewFeedbacksQuestionsGetWithHttpInfo
     *
     * Непросмотренные отзывы и вопросы
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1NewFeedbacksQuestionsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet200Response|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response|\OpenAPI\Client\Model\ResponsefeedbackErr|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV1NewFeedbacksQuestionsGetWithHttpInfo(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1NewFeedbacksQuestionsGet'][0])
    {
        $request = $this->apiV1NewFeedbacksQuestionsGetRequest($hostIndex, $variables, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet200Response',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $request,
                        $response,
                    );
                case 403:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ResponsefeedbackErr',
                        $request,
                        $response,
                    );
                case 429:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ResponsefeedbackErr',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation apiV1NewFeedbacksQuestionsGetAsync
     *
     * Непросмотренные отзывы и вопросы
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1NewFeedbacksQuestionsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV1NewFeedbacksQuestionsGetAsync(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1NewFeedbacksQuestionsGet'][0])
    {
        return $this->apiV1NewFeedbacksQuestionsGetAsyncWithHttpInfo($hostIndex, $variables, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV1NewFeedbacksQuestionsGetAsyncWithHttpInfo
     *
     * Непросмотренные отзывы и вопросы
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1NewFeedbacksQuestionsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV1NewFeedbacksQuestionsGetAsyncWithHttpInfo(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1NewFeedbacksQuestionsGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet200Response';
        $request = $this->apiV1NewFeedbacksQuestionsGetRequest($hostIndex, $variables, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV1NewFeedbacksQuestionsGet'
     *
    * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
    * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1NewFeedbacksQuestionsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiV1NewFeedbacksQuestionsGetRequest(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1NewFeedbacksQuestionsGet'][0])
    {


        $resourcePath = '/api/v1/new-feedbacks-questions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        # Preserve the original behavior of server indexing.
        if ($hostIndex === null) {
            $hostIndex = $this->hostIndex;
        }

        $hostSettings = $this->getHostSettingsForapiV1NewFeedbacksQuestionsGet();

        if ($hostIndex < 0 || $hostIndex >= count($hostSettings)) {
            throw new \InvalidArgumentException("Invalid index {$hostIndex} when selecting the host. Must be less than ".count($hostSettings));
        }
        $operationHost = Configuration::getHostString($hostSettings, $hostIndex, $variables);
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Returns an array of host settings for Operation apiV1NewFeedbacksQuestionsGet
     *
     * @return array an array of host settings
     */
    protected function getHostSettingsForapiV1NewFeedbacksQuestionsGet(): array
    {
        return [
            [
                "url" => "https://feedbacks-api.wildberries.ru",
                "description" => "No description provided",
            ]
        ];
    }

    /**
     * Operation apiV1QuestionGet
     *
     * Получить вопрос по ID
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  string $id ID вопроса (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1QuestionGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ApiV1QuestionGet200Response|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response|\OpenAPI\Client\Model\ResponsefeedbackErr|\OpenAPI\Client\Model\ResponsefeedbackErr|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response
     */
    public function apiV1QuestionGet($id, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1QuestionGet'][0])
    {
        list($response) = $this->apiV1QuestionGetWithHttpInfo($id, $hostIndex, $variables, $contentType);
        return $response;
    }

    /**
     * Operation apiV1QuestionGetWithHttpInfo
     *
     * Получить вопрос по ID
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  string $id ID вопроса (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1QuestionGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ApiV1QuestionGet200Response|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response|\OpenAPI\Client\Model\ResponsefeedbackErr|\OpenAPI\Client\Model\ResponsefeedbackErr|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV1QuestionGetWithHttpInfo($id, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1QuestionGet'][0])
    {
        $request = $this->apiV1QuestionGetRequest($id, $hostIndex, $variables, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiV1QuestionGet200Response',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $request,
                        $response,
                    );
                case 403:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ResponsefeedbackErr',
                        $request,
                        $response,
                    );
                case 422:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ResponsefeedbackErr',
                        $request,
                        $response,
                    );
                case 429:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ApiV1QuestionGet200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1QuestionGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ResponsefeedbackErr',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ResponsefeedbackErr',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation apiV1QuestionGetAsync
     *
     * Получить вопрос по ID
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  string $id ID вопроса (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1QuestionGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV1QuestionGetAsync($id, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1QuestionGet'][0])
    {
        return $this->apiV1QuestionGetAsyncWithHttpInfo($id, $hostIndex, $variables, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV1QuestionGetAsyncWithHttpInfo
     *
     * Получить вопрос по ID
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  string $id ID вопроса (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1QuestionGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV1QuestionGetAsyncWithHttpInfo($id, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1QuestionGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ApiV1QuestionGet200Response';
        $request = $this->apiV1QuestionGetRequest($id, $hostIndex, $variables, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV1QuestionGet'
     *
    * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
    * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  string $id ID вопроса (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1QuestionGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiV1QuestionGetRequest($id, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1QuestionGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling apiV1QuestionGet'
            );
        }


        $resourcePath = '/api/v1/question';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        # Preserve the original behavior of server indexing.
        if ($hostIndex === null) {
            $hostIndex = $this->hostIndex;
        }

        $hostSettings = $this->getHostSettingsForapiV1QuestionGet();

        if ($hostIndex < 0 || $hostIndex >= count($hostSettings)) {
            throw new \InvalidArgumentException("Invalid index {$hostIndex} when selecting the host. Must be less than ".count($hostSettings));
        }
        $operationHost = Configuration::getHostString($hostSettings, $hostIndex, $variables);
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Returns an array of host settings for Operation apiV1QuestionGet
     *
     * @return array an array of host settings
     */
    protected function getHostSettingsForapiV1QuestionGet(): array
    {
        return [
            [
                "url" => "https://feedbacks-api.wildberries.ru",
                "description" => "No description provided",
            ]
        ];
    }

    /**
     * Operation apiV1QuestionsCountGet
     *
     * Количество вопросов
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  int|null $date_from Дата начала периода в формате Unix timestamp (optional)
     * @param  int|null $date_to Дата конца периода в формате Unix timestamp (optional)
     * @param  bool|null $is_answered Есть ли ответ на вопрос:   - &#x60;true&#x60; — да, по умолчанию   - &#x60;false&#x60; — нет (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1QuestionsCountGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ApiV1QuestionsCountGet200Response|\OpenAPI\Client\Model\ResponsefeedbackErr|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response|\OpenAPI\Client\Model\ResponsefeedbackErr|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response
     */
    public function apiV1QuestionsCountGet($date_from = null, $date_to = null, $is_answered = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1QuestionsCountGet'][0])
    {
        list($response) = $this->apiV1QuestionsCountGetWithHttpInfo($date_from, $date_to, $is_answered, $hostIndex, $variables, $contentType);
        return $response;
    }

    /**
     * Operation apiV1QuestionsCountGetWithHttpInfo
     *
     * Количество вопросов
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  int|null $date_from Дата начала периода в формате Unix timestamp (optional)
     * @param  int|null $date_to Дата конца периода в формате Unix timestamp (optional)
     * @param  bool|null $is_answered Есть ли ответ на вопрос:   - &#x60;true&#x60; — да, по умолчанию   - &#x60;false&#x60; — нет (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1QuestionsCountGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ApiV1QuestionsCountGet200Response|\OpenAPI\Client\Model\ResponsefeedbackErr|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response|\OpenAPI\Client\Model\ResponsefeedbackErr|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV1QuestionsCountGetWithHttpInfo($date_from = null, $date_to = null, $is_answered = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1QuestionsCountGet'][0])
    {
        $request = $this->apiV1QuestionsCountGetRequest($date_from, $date_to, $is_answered, $hostIndex, $variables, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiV1QuestionsCountGet200Response',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ResponsefeedbackErr',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $request,
                        $response,
                    );
                case 403:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ResponsefeedbackErr',
                        $request,
                        $response,
                    );
                case 429:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ApiV1QuestionsCountGet200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1QuestionsCountGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ResponsefeedbackErr',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ResponsefeedbackErr',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation apiV1QuestionsCountGetAsync
     *
     * Количество вопросов
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  int|null $date_from Дата начала периода в формате Unix timestamp (optional)
     * @param  int|null $date_to Дата конца периода в формате Unix timestamp (optional)
     * @param  bool|null $is_answered Есть ли ответ на вопрос:   - &#x60;true&#x60; — да, по умолчанию   - &#x60;false&#x60; — нет (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1QuestionsCountGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV1QuestionsCountGetAsync($date_from = null, $date_to = null, $is_answered = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1QuestionsCountGet'][0])
    {
        return $this->apiV1QuestionsCountGetAsyncWithHttpInfo($date_from, $date_to, $is_answered, $hostIndex, $variables, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV1QuestionsCountGetAsyncWithHttpInfo
     *
     * Количество вопросов
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  int|null $date_from Дата начала периода в формате Unix timestamp (optional)
     * @param  int|null $date_to Дата конца периода в формате Unix timestamp (optional)
     * @param  bool|null $is_answered Есть ли ответ на вопрос:   - &#x60;true&#x60; — да, по умолчанию   - &#x60;false&#x60; — нет (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1QuestionsCountGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV1QuestionsCountGetAsyncWithHttpInfo($date_from = null, $date_to = null, $is_answered = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1QuestionsCountGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ApiV1QuestionsCountGet200Response';
        $request = $this->apiV1QuestionsCountGetRequest($date_from, $date_to, $is_answered, $hostIndex, $variables, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV1QuestionsCountGet'
     *
    * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
    * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  int|null $date_from Дата начала периода в формате Unix timestamp (optional)
     * @param  int|null $date_to Дата конца периода в формате Unix timestamp (optional)
     * @param  bool|null $is_answered Есть ли ответ на вопрос:   - &#x60;true&#x60; — да, по умолчанию   - &#x60;false&#x60; — нет (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1QuestionsCountGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiV1QuestionsCountGetRequest($date_from = null, $date_to = null, $is_answered = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1QuestionsCountGet'][0])
    {





        $resourcePath = '/api/v1/questions/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date_from,
            'dateFrom', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date_to,
            'dateTo', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_answered,
            'isAnswered', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        # Preserve the original behavior of server indexing.
        if ($hostIndex === null) {
            $hostIndex = $this->hostIndex;
        }

        $hostSettings = $this->getHostSettingsForapiV1QuestionsCountGet();

        if ($hostIndex < 0 || $hostIndex >= count($hostSettings)) {
            throw new \InvalidArgumentException("Invalid index {$hostIndex} when selecting the host. Must be less than ".count($hostSettings));
        }
        $operationHost = Configuration::getHostString($hostSettings, $hostIndex, $variables);
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Returns an array of host settings for Operation apiV1QuestionsCountGet
     *
     * @return array an array of host settings
     */
    protected function getHostSettingsForapiV1QuestionsCountGet(): array
    {
        return [
            [
                "url" => "https://feedbacks-api.wildberries.ru",
                "description" => "No description provided",
            ]
        ];
    }

    /**
     * Operation apiV1QuestionsCountUnansweredGet
     *
     * Неотвеченные вопросы
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1QuestionsCountUnansweredGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ApiV1QuestionsCountUnansweredGet200Response|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response|\OpenAPI\Client\Model\ResponsefeedbackErr|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response
     */
    public function apiV1QuestionsCountUnansweredGet(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1QuestionsCountUnansweredGet'][0])
    {
        list($response) = $this->apiV1QuestionsCountUnansweredGetWithHttpInfo($hostIndex, $variables, $contentType);
        return $response;
    }

    /**
     * Operation apiV1QuestionsCountUnansweredGetWithHttpInfo
     *
     * Неотвеченные вопросы
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1QuestionsCountUnansweredGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ApiV1QuestionsCountUnansweredGet200Response|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response|\OpenAPI\Client\Model\ResponsefeedbackErr|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV1QuestionsCountUnansweredGetWithHttpInfo(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1QuestionsCountUnansweredGet'][0])
    {
        $request = $this->apiV1QuestionsCountUnansweredGetRequest($hostIndex, $variables, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiV1QuestionsCountUnansweredGet200Response',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $request,
                        $response,
                    );
                case 403:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ResponsefeedbackErr',
                        $request,
                        $response,
                    );
                case 429:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ApiV1QuestionsCountUnansweredGet200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1QuestionsCountUnansweredGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ResponsefeedbackErr',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation apiV1QuestionsCountUnansweredGetAsync
     *
     * Неотвеченные вопросы
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1QuestionsCountUnansweredGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV1QuestionsCountUnansweredGetAsync(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1QuestionsCountUnansweredGet'][0])
    {
        return $this->apiV1QuestionsCountUnansweredGetAsyncWithHttpInfo($hostIndex, $variables, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV1QuestionsCountUnansweredGetAsyncWithHttpInfo
     *
     * Неотвеченные вопросы
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1QuestionsCountUnansweredGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV1QuestionsCountUnansweredGetAsyncWithHttpInfo(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1QuestionsCountUnansweredGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ApiV1QuestionsCountUnansweredGet200Response';
        $request = $this->apiV1QuestionsCountUnansweredGetRequest($hostIndex, $variables, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV1QuestionsCountUnansweredGet'
     *
    * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
    * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1QuestionsCountUnansweredGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiV1QuestionsCountUnansweredGetRequest(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1QuestionsCountUnansweredGet'][0])
    {


        $resourcePath = '/api/v1/questions/count-unanswered';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        # Preserve the original behavior of server indexing.
        if ($hostIndex === null) {
            $hostIndex = $this->hostIndex;
        }

        $hostSettings = $this->getHostSettingsForapiV1QuestionsCountUnansweredGet();

        if ($hostIndex < 0 || $hostIndex >= count($hostSettings)) {
            throw new \InvalidArgumentException("Invalid index {$hostIndex} when selecting the host. Must be less than ".count($hostSettings));
        }
        $operationHost = Configuration::getHostString($hostSettings, $hostIndex, $variables);
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Returns an array of host settings for Operation apiV1QuestionsCountUnansweredGet
     *
     * @return array an array of host settings
     */
    protected function getHostSettingsForapiV1QuestionsCountUnansweredGet(): array
    {
        return [
            [
                "url" => "https://feedbacks-api.wildberries.ru",
                "description" => "No description provided",
            ]
        ];
    }

    /**
     * Operation apiV1QuestionsGet
     *
     * Список вопросов
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  bool $is_answered Есть ли ответ на вопрос:   - &#x60;true&#x60; — да, по умолчанию   - &#x60;false&#x60; — нет (required)
     * @param  int $take Количество запрашиваемых вопросов (максимально допустимое значение для параметра - 10 000, при этом сумма значений параметров &#x60;take&#x60; и &#x60;skip&#x60; не должна превышать 10 000) (required)
     * @param  int $skip Количество вопросов для пропуска (максимально допустимое значение для параметра - 10 000, при этом сумма значений параметров &#x60;take&#x60; и &#x60;skip&#x60; не должна превышать 10 000) (required)
     * @param  int|null $nm_id Артикул WB (optional)
     * @param  string|null $order Сортировка вопросов по дате (&#x60;dateAsc&#x60;/&#x60;dateDesc&#x60;) (optional)
     * @param  int|null $date_from Дата начала периода в формате Unix timestamp (optional)
     * @param  int|null $date_to Дата конца периода в формате Unix timestamp (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1QuestionsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ApiV1QuestionsGet200Response|\OpenAPI\Client\Model\ResponsefeedbackErr|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response|\OpenAPI\Client\Model\ResponsefeedbackErr|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response
     */
    public function apiV1QuestionsGet($is_answered, $take, $skip, $nm_id = null, $order = null, $date_from = null, $date_to = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1QuestionsGet'][0])
    {
        list($response) = $this->apiV1QuestionsGetWithHttpInfo($is_answered, $take, $skip, $nm_id, $order, $date_from, $date_to, $hostIndex, $variables, $contentType);
        return $response;
    }

    /**
     * Operation apiV1QuestionsGetWithHttpInfo
     *
     * Список вопросов
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  bool $is_answered Есть ли ответ на вопрос:   - &#x60;true&#x60; — да, по умолчанию   - &#x60;false&#x60; — нет (required)
     * @param  int $take Количество запрашиваемых вопросов (максимально допустимое значение для параметра - 10 000, при этом сумма значений параметров &#x60;take&#x60; и &#x60;skip&#x60; не должна превышать 10 000) (required)
     * @param  int $skip Количество вопросов для пропуска (максимально допустимое значение для параметра - 10 000, при этом сумма значений параметров &#x60;take&#x60; и &#x60;skip&#x60; не должна превышать 10 000) (required)
     * @param  int|null $nm_id Артикул WB (optional)
     * @param  string|null $order Сортировка вопросов по дате (&#x60;dateAsc&#x60;/&#x60;dateDesc&#x60;) (optional)
     * @param  int|null $date_from Дата начала периода в формате Unix timestamp (optional)
     * @param  int|null $date_to Дата конца периода в формате Unix timestamp (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1QuestionsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ApiV1QuestionsGet200Response|\OpenAPI\Client\Model\ResponsefeedbackErr|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response|\OpenAPI\Client\Model\ResponsefeedbackErr|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV1QuestionsGetWithHttpInfo($is_answered, $take, $skip, $nm_id = null, $order = null, $date_from = null, $date_to = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1QuestionsGet'][0])
    {
        $request = $this->apiV1QuestionsGetRequest($is_answered, $take, $skip, $nm_id, $order, $date_from, $date_to, $hostIndex, $variables, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiV1QuestionsGet200Response',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ResponsefeedbackErr',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $request,
                        $response,
                    );
                case 403:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ResponsefeedbackErr',
                        $request,
                        $response,
                    );
                case 429:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ApiV1QuestionsGet200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1QuestionsGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ResponsefeedbackErr',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ResponsefeedbackErr',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation apiV1QuestionsGetAsync
     *
     * Список вопросов
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  bool $is_answered Есть ли ответ на вопрос:   - &#x60;true&#x60; — да, по умолчанию   - &#x60;false&#x60; — нет (required)
     * @param  int $take Количество запрашиваемых вопросов (максимально допустимое значение для параметра - 10 000, при этом сумма значений параметров &#x60;take&#x60; и &#x60;skip&#x60; не должна превышать 10 000) (required)
     * @param  int $skip Количество вопросов для пропуска (максимально допустимое значение для параметра - 10 000, при этом сумма значений параметров &#x60;take&#x60; и &#x60;skip&#x60; не должна превышать 10 000) (required)
     * @param  int|null $nm_id Артикул WB (optional)
     * @param  string|null $order Сортировка вопросов по дате (&#x60;dateAsc&#x60;/&#x60;dateDesc&#x60;) (optional)
     * @param  int|null $date_from Дата начала периода в формате Unix timestamp (optional)
     * @param  int|null $date_to Дата конца периода в формате Unix timestamp (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1QuestionsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV1QuestionsGetAsync($is_answered, $take, $skip, $nm_id = null, $order = null, $date_from = null, $date_to = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1QuestionsGet'][0])
    {
        return $this->apiV1QuestionsGetAsyncWithHttpInfo($is_answered, $take, $skip, $nm_id, $order, $date_from, $date_to, $hostIndex, $variables, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV1QuestionsGetAsyncWithHttpInfo
     *
     * Список вопросов
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  bool $is_answered Есть ли ответ на вопрос:   - &#x60;true&#x60; — да, по умолчанию   - &#x60;false&#x60; — нет (required)
     * @param  int $take Количество запрашиваемых вопросов (максимально допустимое значение для параметра - 10 000, при этом сумма значений параметров &#x60;take&#x60; и &#x60;skip&#x60; не должна превышать 10 000) (required)
     * @param  int $skip Количество вопросов для пропуска (максимально допустимое значение для параметра - 10 000, при этом сумма значений параметров &#x60;take&#x60; и &#x60;skip&#x60; не должна превышать 10 000) (required)
     * @param  int|null $nm_id Артикул WB (optional)
     * @param  string|null $order Сортировка вопросов по дате (&#x60;dateAsc&#x60;/&#x60;dateDesc&#x60;) (optional)
     * @param  int|null $date_from Дата начала периода в формате Unix timestamp (optional)
     * @param  int|null $date_to Дата конца периода в формате Unix timestamp (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1QuestionsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV1QuestionsGetAsyncWithHttpInfo($is_answered, $take, $skip, $nm_id = null, $order = null, $date_from = null, $date_to = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1QuestionsGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ApiV1QuestionsGet200Response';
        $request = $this->apiV1QuestionsGetRequest($is_answered, $take, $skip, $nm_id, $order, $date_from, $date_to, $hostIndex, $variables, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV1QuestionsGet'
     *
    * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
    * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  bool $is_answered Есть ли ответ на вопрос:   - &#x60;true&#x60; — да, по умолчанию   - &#x60;false&#x60; — нет (required)
     * @param  int $take Количество запрашиваемых вопросов (максимально допустимое значение для параметра - 10 000, при этом сумма значений параметров &#x60;take&#x60; и &#x60;skip&#x60; не должна превышать 10 000) (required)
     * @param  int $skip Количество вопросов для пропуска (максимально допустимое значение для параметра - 10 000, при этом сумма значений параметров &#x60;take&#x60; и &#x60;skip&#x60; не должна превышать 10 000) (required)
     * @param  int|null $nm_id Артикул WB (optional)
     * @param  string|null $order Сортировка вопросов по дате (&#x60;dateAsc&#x60;/&#x60;dateDesc&#x60;) (optional)
     * @param  int|null $date_from Дата начала периода в формате Unix timestamp (optional)
     * @param  int|null $date_to Дата конца периода в формате Unix timestamp (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1QuestionsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiV1QuestionsGetRequest($is_answered, $take, $skip, $nm_id = null, $order = null, $date_from = null, $date_to = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1QuestionsGet'][0])
    {

        // verify the required parameter 'is_answered' is set
        if ($is_answered === null || (is_array($is_answered) && count($is_answered) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $is_answered when calling apiV1QuestionsGet'
            );
        }

        // verify the required parameter 'take' is set
        if ($take === null || (is_array($take) && count($take) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $take when calling apiV1QuestionsGet'
            );
        }

        // verify the required parameter 'skip' is set
        if ($skip === null || (is_array($skip) && count($skip) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $skip when calling apiV1QuestionsGet'
            );
        }






        $resourcePath = '/api/v1/questions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_answered,
            'isAnswered', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $nm_id,
            'nmId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $take,
            'take', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $skip,
            'skip', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order,
            'order', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date_from,
            'dateFrom', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date_to,
            'dateTo', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        # Preserve the original behavior of server indexing.
        if ($hostIndex === null) {
            $hostIndex = $this->hostIndex;
        }

        $hostSettings = $this->getHostSettingsForapiV1QuestionsGet();

        if ($hostIndex < 0 || $hostIndex >= count($hostSettings)) {
            throw new \InvalidArgumentException("Invalid index {$hostIndex} when selecting the host. Must be less than ".count($hostSettings));
        }
        $operationHost = Configuration::getHostString($hostSettings, $hostIndex, $variables);
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Returns an array of host settings for Operation apiV1QuestionsGet
     *
     * @return array an array of host settings
     */
    protected function getHostSettingsForapiV1QuestionsGet(): array
    {
        return [
            [
                "url" => "https://feedbacks-api.wildberries.ru",
                "description" => "No description provided",
            ]
        ];
    }

    /**
     * Operation apiV1QuestionsPatch
     *
     * Работа с вопросами
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  \OpenAPI\Client\Model\ApiV1QuestionsPatchRequest|null $api_v1_questions_patch_request api_v1_questions_patch_request (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1QuestionsPatch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ApiV1QuestionsPatch200Response|\OpenAPI\Client\Model\ResponsefeedbackErr|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response|\OpenAPI\Client\Model\ResponsefeedbackErr|\OpenAPI\Client\Model\ResponsefeedbackErr|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response
     */
    public function apiV1QuestionsPatch($api_v1_questions_patch_request = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1QuestionsPatch'][0])
    {
        list($response) = $this->apiV1QuestionsPatchWithHttpInfo($api_v1_questions_patch_request, $hostIndex, $variables, $contentType);
        return $response;
    }

    /**
     * Operation apiV1QuestionsPatchWithHttpInfo
     *
     * Работа с вопросами
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  \OpenAPI\Client\Model\ApiV1QuestionsPatchRequest|null $api_v1_questions_patch_request (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1QuestionsPatch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ApiV1QuestionsPatch200Response|\OpenAPI\Client\Model\ResponsefeedbackErr|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response|\OpenAPI\Client\Model\ResponsefeedbackErr|\OpenAPI\Client\Model\ResponsefeedbackErr|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV1QuestionsPatchWithHttpInfo($api_v1_questions_patch_request = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1QuestionsPatch'][0])
    {
        $request = $this->apiV1QuestionsPatchRequest($api_v1_questions_patch_request, $hostIndex, $variables, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiV1QuestionsPatch200Response',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ResponsefeedbackErr',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $request,
                        $response,
                    );
                case 403:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ResponsefeedbackErr',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ResponsefeedbackErr',
                        $request,
                        $response,
                    );
                case 429:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ApiV1QuestionsPatch200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1QuestionsPatch200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ResponsefeedbackErr',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ResponsefeedbackErr',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ResponsefeedbackErr',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation apiV1QuestionsPatchAsync
     *
     * Работа с вопросами
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  \OpenAPI\Client\Model\ApiV1QuestionsPatchRequest|null $api_v1_questions_patch_request (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1QuestionsPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV1QuestionsPatchAsync($api_v1_questions_patch_request = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1QuestionsPatch'][0])
    {
        return $this->apiV1QuestionsPatchAsyncWithHttpInfo($api_v1_questions_patch_request, $hostIndex, $variables, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV1QuestionsPatchAsyncWithHttpInfo
     *
     * Работа с вопросами
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  \OpenAPI\Client\Model\ApiV1QuestionsPatchRequest|null $api_v1_questions_patch_request (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1QuestionsPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV1QuestionsPatchAsyncWithHttpInfo($api_v1_questions_patch_request = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1QuestionsPatch'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ApiV1QuestionsPatch200Response';
        $request = $this->apiV1QuestionsPatchRequest($api_v1_questions_patch_request, $hostIndex, $variables, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV1QuestionsPatch'
     *
    * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
    * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://feedbacks-api.wildberries.ru
     *
     * @param  \OpenAPI\Client\Model\ApiV1QuestionsPatchRequest|null $api_v1_questions_patch_request (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1QuestionsPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiV1QuestionsPatchRequest($api_v1_questions_patch_request = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1QuestionsPatch'][0])
    {



        $resourcePath = '/api/v1/questions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($api_v1_questions_patch_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($api_v1_questions_patch_request));
            } else {
                $httpBody = $api_v1_questions_patch_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        # Preserve the original behavior of server indexing.
        if ($hostIndex === null) {
            $hostIndex = $this->hostIndex;
        }

        $hostSettings = $this->getHostSettingsForapiV1QuestionsPatch();

        if ($hostIndex < 0 || $hostIndex >= count($hostSettings)) {
            throw new \InvalidArgumentException("Invalid index {$hostIndex} when selecting the host. Must be less than ".count($hostSettings));
        }
        $operationHost = Configuration::getHostString($hostSettings, $hostIndex, $variables);
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Returns an array of host settings for Operation apiV1QuestionsPatch
     *
     * @return array an array of host settings
     */
    protected function getHostSettingsForapiV1QuestionsPatch(): array
    {
        return [
            [
                "url" => "https://feedbacks-api.wildberries.ru",
                "description" => "No description provided",
            ]
        ];
    }

    /**
     * Operation apiV1SellerChatsGet
     *
     * Список чатов
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://buyer-chat-api.wildberries.ru
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1SellerChatsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ChatsResponse|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response
     */
    public function apiV1SellerChatsGet(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1SellerChatsGet'][0])
    {
        list($response) = $this->apiV1SellerChatsGetWithHttpInfo($hostIndex, $variables, $contentType);
        return $response;
    }

    /**
     * Operation apiV1SellerChatsGetWithHttpInfo
     *
     * Список чатов
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://buyer-chat-api.wildberries.ru
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1SellerChatsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ChatsResponse|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV1SellerChatsGetWithHttpInfo(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1SellerChatsGet'][0])
    {
        $request = $this->apiV1SellerChatsGetRequest($hostIndex, $variables, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ChatsResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $request,
                        $response,
                    );
                case 429:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ChatsResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ChatsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation apiV1SellerChatsGetAsync
     *
     * Список чатов
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://buyer-chat-api.wildberries.ru
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1SellerChatsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV1SellerChatsGetAsync(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1SellerChatsGet'][0])
    {
        return $this->apiV1SellerChatsGetAsyncWithHttpInfo($hostIndex, $variables, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV1SellerChatsGetAsyncWithHttpInfo
     *
     * Список чатов
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://buyer-chat-api.wildberries.ru
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1SellerChatsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV1SellerChatsGetAsyncWithHttpInfo(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1SellerChatsGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ChatsResponse';
        $request = $this->apiV1SellerChatsGetRequest($hostIndex, $variables, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV1SellerChatsGet'
     *
    * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
    * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://buyer-chat-api.wildberries.ru
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1SellerChatsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiV1SellerChatsGetRequest(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1SellerChatsGet'][0])
    {


        $resourcePath = '/api/v1/seller/chats';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        # Preserve the original behavior of server indexing.
        if ($hostIndex === null) {
            $hostIndex = $this->hostIndex;
        }

        $hostSettings = $this->getHostSettingsForapiV1SellerChatsGet();

        if ($hostIndex < 0 || $hostIndex >= count($hostSettings)) {
            throw new \InvalidArgumentException("Invalid index {$hostIndex} when selecting the host. Must be less than ".count($hostSettings));
        }
        $operationHost = Configuration::getHostString($hostSettings, $hostIndex, $variables);
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Returns an array of host settings for Operation apiV1SellerChatsGet
     *
     * @return array an array of host settings
     */
    protected function getHostSettingsForapiV1SellerChatsGet(): array
    {
        return [
            [
                "url" => "https://buyer-chat-api.wildberries.ru",
                "description" => "No description provided",
            ]
        ];
    }

    /**
     * Operation apiV1SellerDownloadIdGet
     *
     * Получить файл из сообщения
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://buyer-chat-api.wildberries.ru
     *
     * @param  string $id ID файла, см. значение поля &#x60;downloadID&#x60; в методе [События чатов](./user-communication#tag/Chat-s-pokupatelyami/paths/~1api~1v1~1seller~1events/get) (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1SellerDownloadIdGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\OpenAPI\Client\Model\ApiV1SellerEventsGet400Response
     */
    public function apiV1SellerDownloadIdGet($id, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1SellerDownloadIdGet'][0])
    {
        list($response) = $this->apiV1SellerDownloadIdGetWithHttpInfo($id, $hostIndex, $variables, $contentType);
        return $response;
    }

    /**
     * Operation apiV1SellerDownloadIdGetWithHttpInfo
     *
     * Получить файл из сообщения
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://buyer-chat-api.wildberries.ru
     *
     * @param  string $id ID файла, см. значение поля &#x60;downloadID&#x60; в методе [События чатов](./user-communication#tag/Chat-s-pokupatelyami/paths/~1api~1v1~1seller~1events/get) (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1SellerDownloadIdGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\OpenAPI\Client\Model\ApiV1SellerEventsGet400Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV1SellerDownloadIdGetWithHttpInfo($id, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1SellerDownloadIdGet'][0])
    {
        $request = $this->apiV1SellerDownloadIdGetRequest($id, $hostIndex, $variables, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\SplFileObject',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiV1SellerEventsGet400Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\SplFileObject',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1SellerEventsGet400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation apiV1SellerDownloadIdGetAsync
     *
     * Получить файл из сообщения
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://buyer-chat-api.wildberries.ru
     *
     * @param  string $id ID файла, см. значение поля &#x60;downloadID&#x60; в методе [События чатов](./user-communication#tag/Chat-s-pokupatelyami/paths/~1api~1v1~1seller~1events/get) (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1SellerDownloadIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV1SellerDownloadIdGetAsync($id, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1SellerDownloadIdGet'][0])
    {
        return $this->apiV1SellerDownloadIdGetAsyncWithHttpInfo($id, $hostIndex, $variables, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV1SellerDownloadIdGetAsyncWithHttpInfo
     *
     * Получить файл из сообщения
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://buyer-chat-api.wildberries.ru
     *
     * @param  string $id ID файла, см. значение поля &#x60;downloadID&#x60; в методе [События чатов](./user-communication#tag/Chat-s-pokupatelyami/paths/~1api~1v1~1seller~1events/get) (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1SellerDownloadIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV1SellerDownloadIdGetAsyncWithHttpInfo($id, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1SellerDownloadIdGet'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->apiV1SellerDownloadIdGetRequest($id, $hostIndex, $variables, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV1SellerDownloadIdGet'
     *
    * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
    * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://buyer-chat-api.wildberries.ru
     *
     * @param  string $id ID файла, см. значение поля &#x60;downloadID&#x60; в методе [События чатов](./user-communication#tag/Chat-s-pokupatelyami/paths/~1api~1v1~1seller~1events/get) (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1SellerDownloadIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiV1SellerDownloadIdGetRequest($id, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1SellerDownloadIdGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling apiV1SellerDownloadIdGet'
            );
        }


        $resourcePath = '/api/v1/seller/download/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/pdf', 'image/jpeg', 'image/png', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        # Preserve the original behavior of server indexing.
        if ($hostIndex === null) {
            $hostIndex = $this->hostIndex;
        }

        $hostSettings = $this->getHostSettingsForapiV1SellerDownloadIdGet();

        if ($hostIndex < 0 || $hostIndex >= count($hostSettings)) {
            throw new \InvalidArgumentException("Invalid index {$hostIndex} when selecting the host. Must be less than ".count($hostSettings));
        }
        $operationHost = Configuration::getHostString($hostSettings, $hostIndex, $variables);
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Returns an array of host settings for Operation apiV1SellerDownloadIdGet
     *
     * @return array an array of host settings
     */
    protected function getHostSettingsForapiV1SellerDownloadIdGet(): array
    {
        return [
            [
                "url" => "https://buyer-chat-api.wildberries.ru",
                "description" => "No description provided",
            ]
        ];
    }

    /**
     * Operation apiV1SellerEventsGet
     *
     * События чатов
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://buyer-chat-api.wildberries.ru
     *
     * @param  int|null $next Пагинатор. С какого момента получить следующий пакет данных.&lt;br&gt;Формат Unix timestamp **с миллисекундами** (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1SellerEventsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\EventsResponse|\OpenAPI\Client\Model\ApiV1SellerEventsGet400Response|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response
     */
    public function apiV1SellerEventsGet($next = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1SellerEventsGet'][0])
    {
        list($response) = $this->apiV1SellerEventsGetWithHttpInfo($next, $hostIndex, $variables, $contentType);
        return $response;
    }

    /**
     * Operation apiV1SellerEventsGetWithHttpInfo
     *
     * События чатов
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://buyer-chat-api.wildberries.ru
     *
     * @param  int|null $next Пагинатор. С какого момента получить следующий пакет данных.&lt;br&gt;Формат Unix timestamp **с миллисекундами** (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1SellerEventsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\EventsResponse|\OpenAPI\Client\Model\ApiV1SellerEventsGet400Response|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV1SellerEventsGetWithHttpInfo($next = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1SellerEventsGet'][0])
    {
        $request = $this->apiV1SellerEventsGetRequest($next, $hostIndex, $variables, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\EventsResponse',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiV1SellerEventsGet400Response',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $request,
                        $response,
                    );
                case 429:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\EventsResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\EventsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1SellerEventsGet400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation apiV1SellerEventsGetAsync
     *
     * События чатов
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://buyer-chat-api.wildberries.ru
     *
     * @param  int|null $next Пагинатор. С какого момента получить следующий пакет данных.&lt;br&gt;Формат Unix timestamp **с миллисекундами** (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1SellerEventsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV1SellerEventsGetAsync($next = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1SellerEventsGet'][0])
    {
        return $this->apiV1SellerEventsGetAsyncWithHttpInfo($next, $hostIndex, $variables, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV1SellerEventsGetAsyncWithHttpInfo
     *
     * События чатов
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://buyer-chat-api.wildberries.ru
     *
     * @param  int|null $next Пагинатор. С какого момента получить следующий пакет данных.&lt;br&gt;Формат Unix timestamp **с миллисекундами** (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1SellerEventsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV1SellerEventsGetAsyncWithHttpInfo($next = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1SellerEventsGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\EventsResponse';
        $request = $this->apiV1SellerEventsGetRequest($next, $hostIndex, $variables, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV1SellerEventsGet'
     *
    * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
    * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://buyer-chat-api.wildberries.ru
     *
     * @param  int|null $next Пагинатор. С какого момента получить следующий пакет данных.&lt;br&gt;Формат Unix timestamp **с миллисекундами** (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1SellerEventsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiV1SellerEventsGetRequest($next = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1SellerEventsGet'][0])
    {



        $resourcePath = '/api/v1/seller/events';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $next,
            'next', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        # Preserve the original behavior of server indexing.
        if ($hostIndex === null) {
            $hostIndex = $this->hostIndex;
        }

        $hostSettings = $this->getHostSettingsForapiV1SellerEventsGet();

        if ($hostIndex < 0 || $hostIndex >= count($hostSettings)) {
            throw new \InvalidArgumentException("Invalid index {$hostIndex} when selecting the host. Must be less than ".count($hostSettings));
        }
        $operationHost = Configuration::getHostString($hostSettings, $hostIndex, $variables);
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Returns an array of host settings for Operation apiV1SellerEventsGet
     *
     * @return array an array of host settings
     */
    protected function getHostSettingsForapiV1SellerEventsGet(): array
    {
        return [
            [
                "url" => "https://buyer-chat-api.wildberries.ru",
                "description" => "No description provided",
            ]
        ];
    }

    /**
     * Operation apiV1SellerMessagePost
     *
     * Отправить сообщение
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://buyer-chat-api.wildberries.ru
     *
     * @param  string $reply_sign Подпись чата. Можно получить из [информации по чату](./user-communication#tag/Chat-s-pokupatelyami/paths/~1api~1v1~1seller~1chats/get) или [данных события](./user-communication#tag/Chat-s-pokupatelyami/paths/~1api~1v1~1seller~1events/get), если в событии есть поле &#x60;\\\&quot;isNewChat\\\&quot;: true&#x60;. (required)
     * @param  string|null $message Текст сообщения. Максимум 1000 символов. (optional)
     * @param  \SplFileObject[]|null $file Файлы, формат JPEG, PDF или PNG, максимальный размер — 5 Мб каждый. Максимальный суммарный размер файлов — 30 Мб. (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1SellerMessagePost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\MessageResponse|\OpenAPI\Client\Model\ApiV1SellerEventsGet400Response|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response
     */
    public function apiV1SellerMessagePost($reply_sign, $message = null, $file = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1SellerMessagePost'][0])
    {
        list($response) = $this->apiV1SellerMessagePostWithHttpInfo($reply_sign, $message, $file, $hostIndex, $variables, $contentType);
        return $response;
    }

    /**
     * Operation apiV1SellerMessagePostWithHttpInfo
     *
     * Отправить сообщение
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://buyer-chat-api.wildberries.ru
     *
     * @param  string $reply_sign Подпись чата. Можно получить из [информации по чату](./user-communication#tag/Chat-s-pokupatelyami/paths/~1api~1v1~1seller~1chats/get) или [данных события](./user-communication#tag/Chat-s-pokupatelyami/paths/~1api~1v1~1seller~1events/get), если в событии есть поле &#x60;\\\&quot;isNewChat\\\&quot;: true&#x60;. (required)
     * @param  string|null $message Текст сообщения. Максимум 1000 символов. (optional)
     * @param  \SplFileObject[]|null $file Файлы, формат JPEG, PDF или PNG, максимальный размер — 5 Мб каждый. Максимальный суммарный размер файлов — 30 Мб. (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1SellerMessagePost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\MessageResponse|\OpenAPI\Client\Model\ApiV1SellerEventsGet400Response|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response|\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV1SellerMessagePostWithHttpInfo($reply_sign, $message = null, $file = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1SellerMessagePost'][0])
    {
        $request = $this->apiV1SellerMessagePostRequest($reply_sign, $message, $file, $hostIndex, $variables, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\MessageResponse',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiV1SellerEventsGet400Response',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $request,
                        $response,
                    );
                case 429:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\MessageResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MessageResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1SellerEventsGet400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApiV1NewFeedbacksQuestionsGet401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation apiV1SellerMessagePostAsync
     *
     * Отправить сообщение
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://buyer-chat-api.wildberries.ru
     *
     * @param  string $reply_sign Подпись чата. Можно получить из [информации по чату](./user-communication#tag/Chat-s-pokupatelyami/paths/~1api~1v1~1seller~1chats/get) или [данных события](./user-communication#tag/Chat-s-pokupatelyami/paths/~1api~1v1~1seller~1events/get), если в событии есть поле &#x60;\\\&quot;isNewChat\\\&quot;: true&#x60;. (required)
     * @param  string|null $message Текст сообщения. Максимум 1000 символов. (optional)
     * @param  \SplFileObject[]|null $file Файлы, формат JPEG, PDF или PNG, максимальный размер — 5 Мб каждый. Максимальный суммарный размер файлов — 30 Мб. (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1SellerMessagePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV1SellerMessagePostAsync($reply_sign, $message = null, $file = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1SellerMessagePost'][0])
    {
        return $this->apiV1SellerMessagePostAsyncWithHttpInfo($reply_sign, $message, $file, $hostIndex, $variables, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV1SellerMessagePostAsyncWithHttpInfo
     *
     * Отправить сообщение
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://buyer-chat-api.wildberries.ru
     *
     * @param  string $reply_sign Подпись чата. Можно получить из [информации по чату](./user-communication#tag/Chat-s-pokupatelyami/paths/~1api~1v1~1seller~1chats/get) или [данных события](./user-communication#tag/Chat-s-pokupatelyami/paths/~1api~1v1~1seller~1events/get), если в событии есть поле &#x60;\\\&quot;isNewChat\\\&quot;: true&#x60;. (required)
     * @param  string|null $message Текст сообщения. Максимум 1000 символов. (optional)
     * @param  \SplFileObject[]|null $file Файлы, формат JPEG, PDF или PNG, максимальный размер — 5 Мб каждый. Максимальный суммарный размер файлов — 30 Мб. (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1SellerMessagePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV1SellerMessagePostAsyncWithHttpInfo($reply_sign, $message = null, $file = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1SellerMessagePost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\MessageResponse';
        $request = $this->apiV1SellerMessagePostRequest($reply_sign, $message, $file, $hostIndex, $variables, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV1SellerMessagePost'
     *
    * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
    * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://buyer-chat-api.wildberries.ru
     *
     * @param  string $reply_sign Подпись чата. Можно получить из [информации по чату](./user-communication#tag/Chat-s-pokupatelyami/paths/~1api~1v1~1seller~1chats/get) или [данных события](./user-communication#tag/Chat-s-pokupatelyami/paths/~1api~1v1~1seller~1events/get), если в событии есть поле &#x60;\\\&quot;isNewChat\\\&quot;: true&#x60;. (required)
     * @param  string|null $message Текст сообщения. Максимум 1000 символов. (optional)
     * @param  \SplFileObject[]|null $file Файлы, формат JPEG, PDF или PNG, максимальный размер — 5 Мб каждый. Максимальный суммарный размер файлов — 30 Мб. (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV1SellerMessagePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiV1SellerMessagePostRequest($reply_sign, $message = null, $file = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['apiV1SellerMessagePost'][0])
    {

        // verify the required parameter 'reply_sign' is set
        if ($reply_sign === null || (is_array($reply_sign) && count($reply_sign) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $reply_sign when calling apiV1SellerMessagePost'
            );
        }
        if (strlen($reply_sign) > 255) {
            throw new \InvalidArgumentException('invalid length for "$reply_sign" when calling DefaultApi.apiV1SellerMessagePost, must be smaller than or equal to 255.');
        }
        
        if ($message !== null && strlen($message) > 1000) {
            throw new \InvalidArgumentException('invalid length for "$message" when calling DefaultApi.apiV1SellerMessagePost, must be smaller than or equal to 1000.');
        }
        


        $resourcePath = '/api/v1/seller/message';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'reply_sign' => $reply_sign,
            'message' => $message,
            'file' => $file,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/problem+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        # Preserve the original behavior of server indexing.
        if ($hostIndex === null) {
            $hostIndex = $this->hostIndex;
        }

        $hostSettings = $this->getHostSettingsForapiV1SellerMessagePost();

        if ($hostIndex < 0 || $hostIndex >= count($hostSettings)) {
            throw new \InvalidArgumentException("Invalid index {$hostIndex} when selecting the host. Must be less than ".count($hostSettings));
        }
        $operationHost = Configuration::getHostString($hostSettings, $hostIndex, $variables);
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Returns an array of host settings for Operation apiV1SellerMessagePost
     *
     * @return array an array of host settings
     */
    protected function getHostSettingsForapiV1SellerMessagePost(): array
    {
        return [
            [
                "url" => "https://buyer-chat-api.wildberries.ru",
                "description" => "No description provided",
            ]
        ];
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        if ($this->config->getCertFile()) {
            $options[RequestOptions::CERT] = $this->config->getCertFile();
        }

        if ($this->config->getKeyFile()) {
            $options[RequestOptions::SSL_KEY] = $this->config->getKeyFile();
        }

        return $options;
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): array {
        if ($dataType === '\SplFileObject') {
            $content = $response->getBody(); //stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ($dataType !== 'string') {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        return [
            ObjectSerializer::deserialize($content, $dataType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
